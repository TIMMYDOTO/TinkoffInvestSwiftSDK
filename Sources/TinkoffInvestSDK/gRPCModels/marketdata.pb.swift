// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: marketdata.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Тип операции со списком подписок.
public enum SubscriptionAction: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///Статус подписки не определен.
  case unspecified // = 0

  ///Подписаться.
  case subscribe // = 1

  ///Отписаться.
  case unsubscribe // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .subscribe
    case 2: self = .unsubscribe
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .subscribe: return 1
    case .unsubscribe: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SubscriptionAction] = [
    .unspecified,
    .subscribe,
    .unsubscribe,
  ]

}

///Интервал свечи.
public enum SubscriptionInterval: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///Интервал свечи не определен.
  case unspecified // = 0

  ///Минутные свечи.
  case oneMinute // = 1

  ///Пятиминутные свечи.
  case fiveMinutes // = 2

  ///Пятнадцатиминутные свечи.
  case fifteenMinutes // = 3

  ///Часовые свечи.
  case oneHour // = 4

  ///Дневные свечи.
  case oneDay // = 5

  ///Двухминутные свечи.
  case subscriptionInterval2Min // = 6

  ///Трехминутные свечи.
  case subscriptionInterval3Min // = 7

  ///Десятиминутные свечи.
  case subscriptionInterval10Min // = 8

  ///Тридцатиминутные свечи.
  case subscriptionInterval30Min // = 9

  ///Двухчасовые свечи.
  case subscriptionInterval2Hour // = 10

  ///Четырехчасовые свечи.
  case subscriptionInterval4Hour // = 11

  ///Недельные свечи.
  case week // = 12

  ///Месячные свечи.
  case month // = 13
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .oneMinute
    case 2: self = .fiveMinutes
    case 3: self = .fifteenMinutes
    case 4: self = .oneHour
    case 5: self = .oneDay
    case 6: self = .subscriptionInterval2Min
    case 7: self = .subscriptionInterval3Min
    case 8: self = .subscriptionInterval10Min
    case 9: self = .subscriptionInterval30Min
    case 10: self = .subscriptionInterval2Hour
    case 11: self = .subscriptionInterval4Hour
    case 12: self = .week
    case 13: self = .month
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .oneMinute: return 1
    case .fiveMinutes: return 2
    case .fifteenMinutes: return 3
    case .oneHour: return 4
    case .oneDay: return 5
    case .subscriptionInterval2Min: return 6
    case .subscriptionInterval3Min: return 7
    case .subscriptionInterval10Min: return 8
    case .subscriptionInterval30Min: return 9
    case .subscriptionInterval2Hour: return 10
    case .subscriptionInterval4Hour: return 11
    case .week: return 12
    case .month: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SubscriptionInterval] = [
    .unspecified,
    .oneMinute,
    .fiveMinutes,
    .fifteenMinutes,
    .oneHour,
    .oneDay,
    .subscriptionInterval2Min,
    .subscriptionInterval3Min,
    .subscriptionInterval10Min,
    .subscriptionInterval30Min,
    .subscriptionInterval2Hour,
    .subscriptionInterval4Hour,
    .week,
    .month,
  ]

}

///Результат подписки.
public enum SubscriptionStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///Статус подписки не определен.
  case unspecified // = 0

  ///Успешно.
  case success // = 1

  ///Инструмент не найден.
  case instrumentNotFound // = 2

  ///Некорректный статус подписки. [Список возможных значений](./marketdata#subscriptionaction).
  case subscriptionActionIsInvalid // = 3

  ///Некорректная глубина стакана. Доступные значения — 1, 10, 20, 30, 40, 50.
  case depthIsInvalid // = 4

  ///Некорректный интервал свечей. [Список возможных значений](./marketdata#subscriptioninterval).
  case intervalIsInvalid // = 5

  ///Превышен лимит на общее количество подписок в рамках стрима. [Лимитная политика](./limits/).
  case limitIsExceeded // = 6

  ///Внутренняя ошибка сервиса.
  case internalError // = 7

  ///Превышен лимит на количество запросов на подписки в течение установленного отрезка времени.
  case tooManyRequests // = 8

  /// Активная подписка не найдена. Ошибка может возникнуть только при отписке от несуществующей подписки.
  case subscriptionNotFound // = 9

  ///Указан некорректный источник.
  case sourceIsInvalid // = 10
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .success
    case 2: self = .instrumentNotFound
    case 3: self = .subscriptionActionIsInvalid
    case 4: self = .depthIsInvalid
    case 5: self = .intervalIsInvalid
    case 6: self = .limitIsExceeded
    case 7: self = .internalError
    case 8: self = .tooManyRequests
    case 9: self = .subscriptionNotFound
    case 10: self = .sourceIsInvalid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .success: return 1
    case .instrumentNotFound: return 2
    case .subscriptionActionIsInvalid: return 3
    case .depthIsInvalid: return 4
    case .intervalIsInvalid: return 5
    case .limitIsExceeded: return 6
    case .internalError: return 7
    case .tooManyRequests: return 8
    case .subscriptionNotFound: return 9
    case .sourceIsInvalid: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SubscriptionStatus] = [
    .unspecified,
    .success,
    .instrumentNotFound,
    .subscriptionActionIsInvalid,
    .depthIsInvalid,
    .intervalIsInvalid,
    .limitIsExceeded,
    .internalError,
    .tooManyRequests,
    .subscriptionNotFound,
    .sourceIsInvalid,
  ]

}

///Типы источников сделок.
public enum TradeSourceType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///Тип источника сделки не определён.
  case tradeSourceUnspecified // = 0

  /// Биржевые сделки.
  case tradeSourceExchange // = 1

  /// Сделки дилера.
  case tradeSourceDealer // = 2

  /// Все сделки.
  case tradeSourceAll // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .tradeSourceUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tradeSourceUnspecified
    case 1: self = .tradeSourceExchange
    case 2: self = .tradeSourceDealer
    case 3: self = .tradeSourceAll
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tradeSourceUnspecified: return 0
    case .tradeSourceExchange: return 1
    case .tradeSourceDealer: return 2
    case .tradeSourceAll: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [TradeSourceType] = [
    .tradeSourceUnspecified,
    .tradeSourceExchange,
    .tradeSourceDealer,
    .tradeSourceAll,
  ]

}

///Направление сделки.
public enum TradeDirection: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///Направление сделки не определено.
  case unspecified // = 0

  ///Покупка.
  case buy // = 1

  ///Продажа.
  case sell // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .buy
    case 2: self = .sell
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .buy: return 1
    case .sell: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [TradeDirection] = [
    .unspecified,
    .buy,
    .sell,
  ]

}

///Интервал свечей. Максимальное значение интервала приведено ориентировочно, может отличаться в большую сторону в зависимости от параметров запроса.
public enum CandleInterval: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///Интервал не определен.
  case unspecified // = 0

  ///От 1 минуты до 1 дня. Максимальное значение `limit` — 2400.
  case candleInterval1Min // = 1

  ///От 5 минут до недели. Максимальное значение `limit` — 2400.
  case candleInterval5Min // = 2

  ///От 15 минут до 3 недель. Максимальное значение `limit` — 2400.
  case candleInterval15Min // = 3

  ///От 1 часа до 3 месяцев. Максимальное значение `limit` — 2400.
  case hour // = 4

  ///От 1 дня до 6 лет. Максимальное значение `limit` — 2400.
  case day // = 5

  ///От 2 минут до 1 дня. Максимальное значение `limit` — 1200.
  case candleInterval2Min // = 6

  ///От 3 минут до 1 дня. Максимальное значение `limit` — 750.
  case candleInterval3Min // = 7

  ///От 10 минут до недели. Максимальное значение `limit` — 1200.
  case candleInterval10Min // = 8

  ///От 30 минут до 3 недель. Максимальное значение `limit` — 1200.
  case candleInterval30Min // = 9

  ///От 2 часов до 3 месяцев. Максимальное значение `limit` — 2400.
  case candleInterval2Hour // = 10

  ///От 4 часов до 3 месяцев. Максимальное значение `limit` — 700.
  case candleInterval4Hour // = 11

  ///От 1 недели до 5 лет. Максимальное значение `limit` — 300.
  case week // = 12

  ///От 1 месяца до 10 лет. Максимальное значение `limit` — 120.
  case month // = 13

  ///От 5 секунд до 200 минут. Максимальное значение `limit` — 2500.
  case candleInterval5Sec // = 14

  ///От 10 секунд до 200 минут. Максимальное значение `limit` — 1250.
  case candleInterval10Sec // = 15

  ///От 30 секунд до 20 часов. Максимальное значение `limit` — 2500.
  case candleInterval30Sec // = 16
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .candleInterval1Min
    case 2: self = .candleInterval5Min
    case 3: self = .candleInterval15Min
    case 4: self = .hour
    case 5: self = .day
    case 6: self = .candleInterval2Min
    case 7: self = .candleInterval3Min
    case 8: self = .candleInterval10Min
    case 9: self = .candleInterval30Min
    case 10: self = .candleInterval2Hour
    case 11: self = .candleInterval4Hour
    case 12: self = .week
    case 13: self = .month
    case 14: self = .candleInterval5Sec
    case 15: self = .candleInterval10Sec
    case 16: self = .candleInterval30Sec
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .candleInterval1Min: return 1
    case .candleInterval5Min: return 2
    case .candleInterval15Min: return 3
    case .hour: return 4
    case .day: return 5
    case .candleInterval2Min: return 6
    case .candleInterval3Min: return 7
    case .candleInterval10Min: return 8
    case .candleInterval30Min: return 9
    case .candleInterval2Hour: return 10
    case .candleInterval4Hour: return 11
    case .week: return 12
    case .month: return 13
    case .candleInterval5Sec: return 14
    case .candleInterval10Sec: return 15
    case .candleInterval30Sec: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [CandleInterval] = [
    .unspecified,
    .candleInterval1Min,
    .candleInterval5Min,
    .candleInterval15Min,
    .hour,
    .day,
    .candleInterval2Min,
    .candleInterval3Min,
    .candleInterval10Min,
    .candleInterval30Min,
    .candleInterval2Hour,
    .candleInterval4Hour,
    .week,
    .month,
    .candleInterval5Sec,
    .candleInterval10Sec,
    .candleInterval30Sec,
  ]

}

public enum CandleSource: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///Источник свечей не определен.
  case unspecified // = 0

  ///Биржевые свечи.
  case exchange // = 1

  ///Свечи  дилера в результате торговли по выходным.
  case dealerWeekend // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .exchange
    case 2: self = .dealerWeekend
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .exchange: return 1
    case .dealerWeekend: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [CandleSource] = [
    .unspecified,
    .exchange,
    .dealerWeekend,
  ]

}

public enum MarketValueType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///Не определен.
  case instrumentValueUnspecified // = 0

  ///Последняя биржевая цена.
  case instrumentValueLastPrice // = 1

  ///Последняя цена дилера.
  case instrumentValueLastPriceDealer // = 2

  ///Цена закрытия.
  case instrumentValueClosePrice // = 3

  ///Цена последней сделки с вечерней сессии.
  case instrumentValueEveningSessionPrice // = 4

  /// Открытый интерес, возвращается только для фьючерсов
  case instrumentValueOpenInterest // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .instrumentValueUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .instrumentValueUnspecified
    case 1: self = .instrumentValueLastPrice
    case 2: self = .instrumentValueLastPriceDealer
    case 3: self = .instrumentValueClosePrice
    case 4: self = .instrumentValueEveningSessionPrice
    case 5: self = .instrumentValueOpenInterest
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .instrumentValueUnspecified: return 0
    case .instrumentValueLastPrice: return 1
    case .instrumentValueLastPriceDealer: return 2
    case .instrumentValueClosePrice: return 3
    case .instrumentValueEveningSessionPrice: return 4
    case .instrumentValueOpenInterest: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [MarketValueType] = [
    .instrumentValueUnspecified,
    .instrumentValueLastPrice,
    .instrumentValueLastPriceDealer,
    .instrumentValueClosePrice,
    .instrumentValueEveningSessionPrice,
    .instrumentValueOpenInterest,
  ]

}

public enum OrderBookType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///Не определен.
  case unspecified // = 0

  ///Биржевой стакан.
  case exchange // = 1

  ///Стакан дилера.
  case dealer // = 2

  ///Стакан биржевой и дилера.
  case all // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .exchange
    case 2: self = .dealer
    case 3: self = .all
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .exchange: return 1
    case .dealer: return 2
    case .all: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OrderBookType] = [
    .unspecified,
    .exchange,
    .dealer,
    .all,
  ]

}

///Тип последней цены
public enum LastPriceType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///Не определен.
  case lastPriceUnspecified // = 0

  /// Цена биржи.
  case lastPriceExchange // = 1

  /// Цена дилера
  case lastPriceDealer // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .lastPriceUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .lastPriceUnspecified
    case 1: self = .lastPriceExchange
    case 2: self = .lastPriceDealer
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .lastPriceUnspecified: return 0
    case .lastPriceExchange: return 1
    case .lastPriceDealer: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [LastPriceType] = [
    .lastPriceUnspecified,
    .lastPriceExchange,
    .lastPriceDealer,
  ]

}

///Запрос подписки или отписки на определенные биржевые данные.
public struct MarketDataRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: MarketDataRequest.OneOf_Payload? = nil

  ///Запрос подписки на свечи.
  public var subscribeCandlesRequest: SubscribeCandlesRequest {
    get {
      if case .subscribeCandlesRequest(let v)? = payload {return v}
      return SubscribeCandlesRequest()
    }
    set {payload = .subscribeCandlesRequest(newValue)}
  }

  ///Запрос подписки на стаканы.
  public var subscribeOrderBookRequest: SubscribeOrderBookRequest {
    get {
      if case .subscribeOrderBookRequest(let v)? = payload {return v}
      return SubscribeOrderBookRequest()
    }
    set {payload = .subscribeOrderBookRequest(newValue)}
  }

  ///Запрос подписки на ленту обезличенных сделок.
  public var subscribeTradesRequest: SubscribeTradesRequest {
    get {
      if case .subscribeTradesRequest(let v)? = payload {return v}
      return SubscribeTradesRequest()
    }
    set {payload = .subscribeTradesRequest(newValue)}
  }

  ///Запрос подписки на торговые статусы инструментов.
  public var subscribeInfoRequest: SubscribeInfoRequest {
    get {
      if case .subscribeInfoRequest(let v)? = payload {return v}
      return SubscribeInfoRequest()
    }
    set {payload = .subscribeInfoRequest(newValue)}
  }

  ///Запрос подписки на цены последних сделок.
  public var subscribeLastPriceRequest: SubscribeLastPriceRequest {
    get {
      if case .subscribeLastPriceRequest(let v)? = payload {return v}
      return SubscribeLastPriceRequest()
    }
    set {payload = .subscribeLastPriceRequest(newValue)}
  }

  ///Запрос своих подписок.
  public var getMySubscriptions: GetMySubscriptions {
    get {
      if case .getMySubscriptions(let v)? = payload {return v}
      return GetMySubscriptions()
    }
    set {payload = .getMySubscriptions(newValue)}
  }

  ///Запрос проверки активности соединения.
  public var ping: PingRequest {
    get {
      if case .ping(let v)? = payload {return v}
      return PingRequest()
    }
    set {payload = .ping(newValue)}
  }

  ///Запрос настройки пинга.
  public var pingSettings: PingDelaySettings {
    get {
      if case .pingSettings(let v)? = payload {return v}
      return PingDelaySettings()
    }
    set {payload = .pingSettings(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    ///Запрос подписки на свечи.
    case subscribeCandlesRequest(SubscribeCandlesRequest)
    ///Запрос подписки на стаканы.
    case subscribeOrderBookRequest(SubscribeOrderBookRequest)
    ///Запрос подписки на ленту обезличенных сделок.
    case subscribeTradesRequest(SubscribeTradesRequest)
    ///Запрос подписки на торговые статусы инструментов.
    case subscribeInfoRequest(SubscribeInfoRequest)
    ///Запрос подписки на цены последних сделок.
    case subscribeLastPriceRequest(SubscribeLastPriceRequest)
    ///Запрос своих подписок.
    case getMySubscriptions(GetMySubscriptions)
    ///Запрос проверки активности соединения.
    case ping(PingRequest)
    ///Запрос настройки пинга.
    case pingSettings(PingDelaySettings)

  }

  public init() {}
}

public struct MarketDataServerSideStreamRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Запрос подписки на свечи.
  public var subscribeCandlesRequest: SubscribeCandlesRequest {
    get {return _subscribeCandlesRequest ?? SubscribeCandlesRequest()}
    set {_subscribeCandlesRequest = newValue}
  }
  /// Returns true if `subscribeCandlesRequest` has been explicitly set.
  public var hasSubscribeCandlesRequest: Bool {return self._subscribeCandlesRequest != nil}
  /// Clears the value of `subscribeCandlesRequest`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribeCandlesRequest() {self._subscribeCandlesRequest = nil}

  ///Запрос подписки на стаканы.
  public var subscribeOrderBookRequest: SubscribeOrderBookRequest {
    get {return _subscribeOrderBookRequest ?? SubscribeOrderBookRequest()}
    set {_subscribeOrderBookRequest = newValue}
  }
  /// Returns true if `subscribeOrderBookRequest` has been explicitly set.
  public var hasSubscribeOrderBookRequest: Bool {return self._subscribeOrderBookRequest != nil}
  /// Clears the value of `subscribeOrderBookRequest`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribeOrderBookRequest() {self._subscribeOrderBookRequest = nil}

  ///Запрос подписки на ленту обезличенных сделок.
  public var subscribeTradesRequest: SubscribeTradesRequest {
    get {return _subscribeTradesRequest ?? SubscribeTradesRequest()}
    set {_subscribeTradesRequest = newValue}
  }
  /// Returns true if `subscribeTradesRequest` has been explicitly set.
  public var hasSubscribeTradesRequest: Bool {return self._subscribeTradesRequest != nil}
  /// Clears the value of `subscribeTradesRequest`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribeTradesRequest() {self._subscribeTradesRequest = nil}

  ///Запрос подписки на торговые статусы инструментов.
  public var subscribeInfoRequest: SubscribeInfoRequest {
    get {return _subscribeInfoRequest ?? SubscribeInfoRequest()}
    set {_subscribeInfoRequest = newValue}
  }
  /// Returns true if `subscribeInfoRequest` has been explicitly set.
  public var hasSubscribeInfoRequest: Bool {return self._subscribeInfoRequest != nil}
  /// Clears the value of `subscribeInfoRequest`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribeInfoRequest() {self._subscribeInfoRequest = nil}

  ///Запрос подписки на цены последних сделок.
  public var subscribeLastPriceRequest: SubscribeLastPriceRequest {
    get {return _subscribeLastPriceRequest ?? SubscribeLastPriceRequest()}
    set {_subscribeLastPriceRequest = newValue}
  }
  /// Returns true if `subscribeLastPriceRequest` has been explicitly set.
  public var hasSubscribeLastPriceRequest: Bool {return self._subscribeLastPriceRequest != nil}
  /// Clears the value of `subscribeLastPriceRequest`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribeLastPriceRequest() {self._subscribeLastPriceRequest = nil}

  ///Запрос настройки пинга.
  public var pingSettings: PingDelaySettings {
    get {return _pingSettings ?? PingDelaySettings()}
    set {_pingSettings = newValue}
  }
  /// Returns true if `pingSettings` has been explicitly set.
  public var hasPingSettings: Bool {return self._pingSettings != nil}
  /// Clears the value of `pingSettings`. Subsequent reads from it will return its default value.
  public mutating func clearPingSettings() {self._pingSettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _subscribeCandlesRequest: SubscribeCandlesRequest? = nil
  fileprivate var _subscribeOrderBookRequest: SubscribeOrderBookRequest? = nil
  fileprivate var _subscribeTradesRequest: SubscribeTradesRequest? = nil
  fileprivate var _subscribeInfoRequest: SubscribeInfoRequest? = nil
  fileprivate var _subscribeLastPriceRequest: SubscribeLastPriceRequest? = nil
  fileprivate var _pingSettings: PingDelaySettings? = nil
}

///Пакет биржевой информации по подписке.
public struct MarketDataResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: MarketDataResponse.OneOf_Payload? = nil

  ///Результат подписки на свечи.
  public var subscribeCandlesResponse: SubscribeCandlesResponse {
    get {
      if case .subscribeCandlesResponse(let v)? = payload {return v}
      return SubscribeCandlesResponse()
    }
    set {payload = .subscribeCandlesResponse(newValue)}
  }

  ///Результат подписки на стаканы.
  public var subscribeOrderBookResponse: SubscribeOrderBookResponse {
    get {
      if case .subscribeOrderBookResponse(let v)? = payload {return v}
      return SubscribeOrderBookResponse()
    }
    set {payload = .subscribeOrderBookResponse(newValue)}
  }

  ///Результат подписки на поток обезличенных сделок.
  public var subscribeTradesResponse: SubscribeTradesResponse {
    get {
      if case .subscribeTradesResponse(let v)? = payload {return v}
      return SubscribeTradesResponse()
    }
    set {payload = .subscribeTradesResponse(newValue)}
  }

  ///Результат подписки на торговые статусы инструментов.
  public var subscribeInfoResponse: SubscribeInfoResponse {
    get {
      if case .subscribeInfoResponse(let v)? = payload {return v}
      return SubscribeInfoResponse()
    }
    set {payload = .subscribeInfoResponse(newValue)}
  }

  ///Свеча.
  public var candle: Candle {
    get {
      if case .candle(let v)? = payload {return v}
      return Candle()
    }
    set {payload = .candle(newValue)}
  }

  ///Сделки.
  public var trade: Trade {
    get {
      if case .trade(let v)? = payload {return v}
      return Trade()
    }
    set {payload = .trade(newValue)}
  }

  ///Стакан.
  public var orderbook: OrderBook {
    get {
      if case .orderbook(let v)? = payload {return v}
      return OrderBook()
    }
    set {payload = .orderbook(newValue)}
  }

  ///Торговый статус.
  public var tradingStatus: TradingStatus {
    get {
      if case .tradingStatus(let v)? = payload {return v}
      return TradingStatus()
    }
    set {payload = .tradingStatus(newValue)}
  }

  ///Проверка активности стрима.
  public var ping: Ping {
    get {
      if case .ping(let v)? = payload {return v}
      return Ping()
    }
    set {payload = .ping(newValue)}
  }

  ///Результат подписки на цены последние сделок по инструментам.
  public var subscribeLastPriceResponse: SubscribeLastPriceResponse {
    get {
      if case .subscribeLastPriceResponse(let v)? = payload {return v}
      return SubscribeLastPriceResponse()
    }
    set {payload = .subscribeLastPriceResponse(newValue)}
  }

  ///Цена последней сделки.
  public var lastPrice: LastPrice {
    get {
      if case .lastPrice(let v)? = payload {return v}
      return LastPrice()
    }
    set {payload = .lastPrice(newValue)}
  }

  ///Открытый интерес.
  public var openInterest: OpenInterest {
    get {
      if case .openInterest(let v)? = payload {return v}
      return OpenInterest()
    }
    set {payload = .openInterest(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    ///Результат подписки на свечи.
    case subscribeCandlesResponse(SubscribeCandlesResponse)
    ///Результат подписки на стаканы.
    case subscribeOrderBookResponse(SubscribeOrderBookResponse)
    ///Результат подписки на поток обезличенных сделок.
    case subscribeTradesResponse(SubscribeTradesResponse)
    ///Результат подписки на торговые статусы инструментов.
    case subscribeInfoResponse(SubscribeInfoResponse)
    ///Свеча.
    case candle(Candle)
    ///Сделки.
    case trade(Trade)
    ///Стакан.
    case orderbook(OrderBook)
    ///Торговый статус.
    case tradingStatus(TradingStatus)
    ///Проверка активности стрима.
    case ping(Ping)
    ///Результат подписки на цены последние сделок по инструментам.
    case subscribeLastPriceResponse(SubscribeLastPriceResponse)
    ///Цена последней сделки.
    case lastPrice(LastPrice)
    ///Открытый интерес.
    case openInterest(OpenInterest)

  }

  public init() {}
}

/// subscribeCandles | Изменения статуса подписки на свечи.
public struct SubscribeCandlesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на свечи.
  public var instruments: [CandleInstrument] = []

  ///Флаг ожидания закрытия временного интервала для отправки свечи.
  public var waitingClose: Bool = false

  ///Источник свечей.
  public var candleSourceType: GetCandlesRequest.CandleSource {
    get {return _candleSourceType ?? .unspecified}
    set {_candleSourceType = newValue}
  }
  /// Returns true if `candleSourceType` has been explicitly set.
  public var hasCandleSourceType: Bool {return self._candleSourceType != nil}
  /// Clears the value of `candleSourceType`. Subsequent reads from it will return its default value.
  public mutating func clearCandleSourceType() {self._candleSourceType = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _candleSourceType: GetCandlesRequest.CandleSource? = nil
}

///Запрос изменения статус подписки на свечи.
public struct CandleInstrument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var figi: String = String()

  ///Интервал свечей. Двухчасовые и четырехчасовые свечи в стриме отсчитываются с 0:00 по UTC.
  public var interval: SubscriptionInterval = .unspecified

  ///Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`.
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статус подписки на свечи.
public struct SubscribeCandlesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса. [Подробнее](./grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на свечи.
  public var candlesSubscriptions: [CandleSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки на свечи.
public struct CandleSubscription: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///FIGI-идентификатор инструмента.
  public var figi: String = String()

  ///Интервал свечей.
  public var interval: SubscriptionInterval = .unspecified

  ///Статус подписки.
  public var subscriptionStatus: SubscriptionStatus = .unspecified

  ///UID инструмента.
  public var instrumentUid: String = String()

  ///Флаг ожидания закрытия временного интервала для отправки свечи.
  public var waitingClose: Bool = false

  ///Идентификатор открытого соединения.
  public var streamID: String = String()

  ///Идентификатор подписки в формате `UUID`.
  public var subscriptionID: String = String()

  ///Действие подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  ///Источник свечей.
  public var candleSourceType: GetCandlesRequest.CandleSource {
    get {return _candleSourceType ?? .unspecified}
    set {_candleSourceType = newValue}
  }
  /// Returns true if `candleSourceType` has been explicitly set.
  public var hasCandleSourceType: Bool {return self._candleSourceType != nil}
  /// Clears the value of `candleSourceType`. Subsequent reads from it will return its default value.
  public mutating func clearCandleSourceType() {self._candleSourceType = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _candleSourceType: GetCandlesRequest.CandleSource? = nil
}

///Запрос на изменение статуса подписки на стаканы.
public struct SubscribeOrderBookRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на стаканы.
  public var instruments: [OrderBookInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на стаканы.
public struct OrderBookInstrument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`.
  public var instrumentID: String = String()

  ///Тип стакана. Значение по умолчанию — `ORDERBOOK_TYPE_ALL`, стакан биржевой и дилера.
  public var orderBookType: OrderBookType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на стаканы.
public struct SubscribeOrderBookResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса. [Подробнее](./grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на стаканы.
  public var orderBookSubscriptions: [OrderBookSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки.
public struct OrderBookSubscription: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///FIGI-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Статус подписки.
  public var subscriptionStatus: SubscriptionStatus = .unspecified

  ///UID инструмента.
  public var instrumentUid: String = String()

  ///Идентификатор открытого соединения.
  public var streamID: String = String()

  ///Идентификатор подписки в формате `UUID`.
  public var subscriptionID: String = String()

  ///Тип стакана.
  public var orderBookType: OrderBookType = .unspecified

  ///Действие подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Изменение статуса подписки на поток обезличенных сделок.
public struct SubscribeTradesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на поток обезличенных сделок.
  public var instruments: [TradeInstrument] = []

  ///Тип источника сделок. Значение по умолчанию — `TRADE_SOURCE_ALL`, все сделки.
  public var tradeSource: TradeSourceType = .tradeSourceUnspecified

  ///Флаг открытого интереса. **true** - в стриме дополнительно передается информация об открытом интересе для фьючерсов
  public var withOpenInterest: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на поток обезличенных сделок.
public struct TradeInstrument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated FIGI-идентификатор инструмента. Используйте instrument_id`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var figi: String = String()

  ///Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`.
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на поток обезличенных сделок.
public struct SubscribeTradesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса. [Подробнее](./grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на поток сделок.
  public var tradeSubscriptions: [TradeSubscription] = []

  ///Тип источника сделок.
  public var tradeSource: TradeSourceType = .tradeSourceUnspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки.
public struct TradeSubscription: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///FIGI-идентификатор инструмента.
  public var figi: String = String()

  ///Статус подписки.
  public var subscriptionStatus: SubscriptionStatus = .unspecified

  ///UID инструмента.
  public var instrumentUid: String = String()

  ///Идентификатор открытого соединения.
  public var streamID: String = String()

  ///Идентификатор подписки в формате UUID.
  public var subscriptionID: String = String()

  ///Флаг открытого интереса. **true** - в стриме дополнительно передается информация об открытом интересе для фьючерсов
  public var withOpenInterest: Bool = false

  ///Действие подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Изменение статуса подписки на торговый статус инструмента.
public struct SubscribeInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на торговый статус.
  public var instruments: [InfoInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на торговый статус.
public struct InfoInstrument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated FIGI-идентификатор инструмента. Используйте instrument_id`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var figi: String = String()

  ///Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`.
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на торговый статус.
public struct SubscribeInfoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса. [Подробнее](./grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на торговый статус.
  public var infoSubscriptions: [InfoSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки.
public struct InfoSubscription: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///FIGI-идентификатор инструмента.
  public var figi: String = String()

  ///Статус подписки.
  public var subscriptionStatus: SubscriptionStatus = .unspecified

  ///UID инструмента.
  public var instrumentUid: String = String()

  ///Идентификатор открытого соединения.
  public var streamID: String = String()

  ///Идентификатор подписки в формате UUID.
  public var subscriptionID: String = String()

  ///Действие подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Изменение статуса подписки на цену последней сделки по инструменту.
public struct SubscribeLastPriceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Изменение статуса подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  ///Массив инструментов для подписки на цену последней сделки.
  public var instruments: [LastPriceInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос подписки на последнюю цену.
public struct LastPriceInstrument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated FIGI-идентификатор инструмента. Используйте instrument_id`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var figi: String = String()

  ///Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`.
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Результат изменения статуса подписки на цену последней сделки.
public struct SubscribeLastPriceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Уникальный идентификатор запроса. [Подробнее](./grpc#tracking-id).
  public var trackingID: String = String()

  ///Массив статусов подписки на цену последней сделки.
  public var lastPriceSubscriptions: [LastPriceSubscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Статус подписки на цену последней сделки.
public struct LastPriceSubscription: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///FIGI-идентификатор инструмента.
  public var figi: String = String()

  ///Статус подписки.
  public var subscriptionStatus: SubscriptionStatus = .unspecified

  ///UID инструмента.
  public var instrumentUid: String = String()

  ///Идентификатор открытого соединения.
  public var streamID: String = String()

  ///Идентификатор подписки в формате `UUID`.
  public var subscriptionID: String = String()

  ///Действие подписки.
  public var subscriptionAction: SubscriptionAction = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Пакет свечей в рамках стрима.
public struct Candle: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///FIGI-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Интервал свечи.
  public var interval: SubscriptionInterval {
    get {return _storage._interval}
    set {_uniqueStorage()._interval = newValue}
  }

  ///Цена открытия за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var `open`: Quotation {
    get {return _storage._open ?? Quotation()}
    set {_uniqueStorage()._open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  public var hasOpen: Bool {return _storage._open != nil}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  public mutating func clearOpen() {_uniqueStorage()._open = nil}

  ///Максимальная цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var high: Quotation {
    get {return _storage._high ?? Quotation()}
    set {_uniqueStorage()._high = newValue}
  }
  /// Returns true if `high` has been explicitly set.
  public var hasHigh: Bool {return _storage._high != nil}
  /// Clears the value of `high`. Subsequent reads from it will return its default value.
  public mutating func clearHigh() {_uniqueStorage()._high = nil}

  ///Минимальная цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var low: Quotation {
    get {return _storage._low ?? Quotation()}
    set {_uniqueStorage()._low = newValue}
  }
  /// Returns true if `low` has been explicitly set.
  public var hasLow: Bool {return _storage._low != nil}
  /// Clears the value of `low`. Subsequent reads from it will return its default value.
  public mutating func clearLow() {_uniqueStorage()._low = nil}

  ///Цена закрытия за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var close: Quotation {
    get {return _storage._close ?? Quotation()}
    set {_uniqueStorage()._close = newValue}
  }
  /// Returns true if `close` has been explicitly set.
  public var hasClose: Bool {return _storage._close != nil}
  /// Clears the value of `close`. Subsequent reads from it will return its default value.
  public mutating func clearClose() {_uniqueStorage()._close = nil}

  ///Объем сделок в лотах.
  public var volume: Int64 {
    get {return _storage._volume}
    set {_uniqueStorage()._volume = newValue}
  }

  ///Время начала интервала свечи по UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {_uniqueStorage()._time = nil}

  ///Время последней сделки, вошедшей в свечу по UTC.
  public var lastTradeTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastTradeTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastTradeTs = newValue}
  }
  /// Returns true if `lastTradeTs` has been explicitly set.
  public var hasLastTradeTs: Bool {return _storage._lastTradeTs != nil}
  /// Clears the value of `lastTradeTs`. Subsequent reads from it will return its default value.
  public mutating func clearLastTradeTs() {_uniqueStorage()._lastTradeTs = nil}

  ///UID инструмента.
  public var instrumentUid: String {
    get {return _storage._instrumentUid}
    set {_uniqueStorage()._instrumentUid = newValue}
  }

  ///Источник свечей.
  public var candleSourceType: CandleSource {
    get {return _storage._candleSourceType}
    set {_uniqueStorage()._candleSourceType = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Пакет стаканов в рамках стрима.
public struct OrderBook: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///FIGI-идентификатор инструмента.
  public var figi: String = String()

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Флаг консистентности стакана. **false** — не все заявки попали в стакан из-за сетевых задержек или нарушения порядка доставки.
  public var isConsistent: Bool = false

  ///Массив предложений.
  public var bids: [Order] = []

  ///Массив спроса.
  public var asks: [Order] = []

  ///Время формирования стакана в часовом поясе UTC по времени биржи.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Верхний лимит цены за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var limitUp: Quotation {
    get {return _limitUp ?? Quotation()}
    set {_limitUp = newValue}
  }
  /// Returns true if `limitUp` has been explicitly set.
  public var hasLimitUp: Bool {return self._limitUp != nil}
  /// Clears the value of `limitUp`. Subsequent reads from it will return its default value.
  public mutating func clearLimitUp() {self._limitUp = nil}

  ///Нижний лимит цены за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var limitDown: Quotation {
    get {return _limitDown ?? Quotation()}
    set {_limitDown = newValue}
  }
  /// Returns true if `limitDown` has been explicitly set.
  public var hasLimitDown: Bool {return self._limitDown != nil}
  /// Clears the value of `limitDown`. Subsequent reads from it will return its default value.
  public mutating func clearLimitDown() {self._limitDown = nil}

  ///UID инструмента.
  public var instrumentUid: String = String()

  ///Тип стакана.
  public var orderBookType: OrderBookType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _limitUp: Quotation? = nil
  fileprivate var _limitDown: Quotation? = nil
}

///Массив предложений/спроса.
public struct Order: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var price: Quotation {
    get {return _price ?? Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Количество в лотах.
  public var quantity: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Quotation? = nil
}

///Информация о сделке.
public struct Trade: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///FIGI-идентификатор инструмента.
  public var figi: String = String()

  ///Направление сделки.
  public var direction: TradeDirection = .unspecified

  ///Цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var price: Quotation {
    get {return _price ?? Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Количество лотов.
  public var quantity: Int64 = 0

  ///Время сделки в часовом поясе UTC по времени биржи.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///UID инструмента.
  public var instrumentUid: String = String()

  ///Тип источника сделки.
  public var tradeSource: TradeSourceType = .tradeSourceUnspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Пакет изменения торгового статуса.
public struct TradingStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///FIGI-идентификатор инструмента.
  public var figi: String = String()

  ///Статус торговли инструментом.
  public var tradingStatus: SecurityTradingStatus = .unspecified

  ///Время изменения торгового статуса по UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Признак доступности выставления лимитной заявки по инструменту.
  public var limitOrderAvailableFlag: Bool = false

  ///Признак доступности выставления рыночной заявки по инструменту.
  public var marketOrderAvailableFlag: Bool = false

  ///UID инструмента.
  public var instrumentUid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос исторических свечей.
public struct GetCandlesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var figi: String {
    get {return _figi ?? String()}
    set {_figi = newValue}
  }
  /// Returns true if `figi` has been explicitly set.
  public var hasFigi: Bool {return self._figi != nil}
  /// Clears the value of `figi`. Subsequent reads from it will return its default value.
  public mutating func clearFigi() {self._figi = nil}

  ///Начало запрашиваемого периода по UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание запрашиваемого периода по UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  ///Интервал запрошенных свечей.
  public var interval: CandleInterval = .unspecified

  ///Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`.
  public var instrumentID: String {
    get {return _instrumentID ?? String()}
    set {_instrumentID = newValue}
  }
  /// Returns true if `instrumentID` has been explicitly set.
  public var hasInstrumentID: Bool {return self._instrumentID != nil}
  /// Clears the value of `instrumentID`. Subsequent reads from it will return its default value.
  public mutating func clearInstrumentID() {self._instrumentID = nil}

  ///Тип источника свечи.
  public var candleSourceType: GetCandlesRequest.CandleSource {
    get {return _candleSourceType ?? .unspecified}
    set {_candleSourceType = newValue}
  }
  /// Returns true if `candleSourceType` has been explicitly set.
  public var hasCandleSourceType: Bool {return self._candleSourceType != nil}
  /// Clears the value of `candleSourceType`. Subsequent reads from it will return its default value.
  public mutating func clearCandleSourceType() {self._candleSourceType = nil}

  ///Максимальное количество свечей в ответе.
  public var limit: Int32 {
    get {return _limit ?? 0}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum CandleSource: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    ///Все свечи.
    case unspecified // = 0

    ///Биржевые свечи.
    case exchange // = 1

    ///Все свечи с учетом торговли по выходным.
    case includeWeekend // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .exchange
      case 3: self = .includeWeekend
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .exchange: return 1
      case .includeWeekend: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [GetCandlesRequest.CandleSource] = [
      .unspecified,
      .exchange,
      .includeWeekend,
    ]

  }

  public init() {}

  fileprivate var _figi: String? = nil
  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _instrumentID: String? = nil
  fileprivate var _candleSourceType: GetCandlesRequest.CandleSource? = nil
  fileprivate var _limit: Int32? = nil
}

///Список свечей.
public struct GetCandlesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив свечей.
  public var candles: [HistoricCandle] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о свече.
public struct HistoricCandle: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Цена открытия за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var `open`: Quotation {
    get {return _open ?? Quotation()}
    set {_open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  public var hasOpen: Bool {return self._open != nil}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  public mutating func clearOpen() {self._open = nil}

  ///Максимальная цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var high: Quotation {
    get {return _high ?? Quotation()}
    set {_high = newValue}
  }
  /// Returns true if `high` has been explicitly set.
  public var hasHigh: Bool {return self._high != nil}
  /// Clears the value of `high`. Subsequent reads from it will return its default value.
  public mutating func clearHigh() {self._high = nil}

  ///Минимальная цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var low: Quotation {
    get {return _low ?? Quotation()}
    set {_low = newValue}
  }
  /// Returns true if `low` has been explicitly set.
  public var hasLow: Bool {return self._low != nil}
  /// Clears the value of `low`. Subsequent reads from it will return its default value.
  public mutating func clearLow() {self._low = nil}

  ///Цена закрытия за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var close: Quotation {
    get {return _close ?? Quotation()}
    set {_close = newValue}
  }
  /// Returns true if `close` has been explicitly set.
  public var hasClose: Bool {return self._close != nil}
  /// Clears the value of `close`. Subsequent reads from it will return its default value.
  public mutating func clearClose() {self._close = nil}

  ///Объем торгов в лотах.
  public var volume: Int64 = 0

  ///Время свечи в часовом поясе UTC.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Признак завершенности свечи. **false** — свеча за текущие интервал еще сформирована не полностью.
  public var isComplete: Bool = false

  ///Тип источника свечи
  public var candleSource: CandleSource = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _open: Quotation? = nil
  fileprivate var _high: Quotation? = nil
  fileprivate var _low: Quotation? = nil
  fileprivate var _close: Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос получения цен последних сделок.
public struct GetLastPricesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var figi: [String] = []

  ///Массив идентификаторов инструмента. Принимает значения `figi` или `instrument_uid`.
  public var instrumentID: [String] = []

  ///Тип запрашиваемой последней цены.
  public var lastPriceType: LastPriceType = .lastPriceUnspecified

  ///Статус запрашиваемых инструментов. [Возможные значения](#instrumentstatus).
  public var instrumentStatus: InstrumentStatus {
    get {return _instrumentStatus ?? .unspecified}
    set {_instrumentStatus = newValue}
  }
  /// Returns true if `instrumentStatus` has been explicitly set.
  public var hasInstrumentStatus: Bool {return self._instrumentStatus != nil}
  /// Clears the value of `instrumentStatus`. Subsequent reads from it will return its default value.
  public mutating func clearInstrumentStatus() {self._instrumentStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrumentStatus: InstrumentStatus? = nil
}

///Список цен последних сделок.
public struct GetLastPricesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив цен последних сделок.
  public var lastPrices: [LastPrice] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о цене последней сделки.
public struct LastPrice: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///FIGI инструмента.
  public var figi: String = String()

  ///Цена последней сделки за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var price: Quotation {
    get {return _price ?? Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Время получения последней цены в часовом поясе UTC по времени биржи.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///UID инструмента.
  public var instrumentUid: String = String()

  ///Тип последней цены.
  public var lastPriceType: LastPriceType = .lastPriceUnspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct OpenInterest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///UID инструмента.
  public var instrumentUid: String = String()

  ///Время получения открытого интереса в часовом поясе UTC по времени биржи.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Открытый интерес.
  public var openInterest: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

///Запрос стакана.
public struct GetOrderBookRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var figi: String {
    get {return _figi ?? String()}
    set {_figi = newValue}
  }
  /// Returns true if `figi` has been explicitly set.
  public var hasFigi: Bool {return self._figi != nil}
  /// Clears the value of `figi`. Subsequent reads from it will return its default value.
  public mutating func clearFigi() {self._figi = nil}

  ///Глубина стакана.
  public var depth: Int32 = 0

  ///Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`.
  public var instrumentID: String {
    get {return _instrumentID ?? String()}
    set {_instrumentID = newValue}
  }
  /// Returns true if `instrumentID` has been explicitly set.
  public var hasInstrumentID: Bool {return self._instrumentID != nil}
  /// Clears the value of `instrumentID`. Subsequent reads from it will return its default value.
  public mutating func clearInstrumentID() {self._instrumentID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _figi: String? = nil
  fileprivate var _instrumentID: String? = nil
}

///Информация о стакане.
public struct GetOrderBookResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///FIGI-идентификатор инструмента.
  public var figi: String {
    get {return _storage._figi}
    set {_uniqueStorage()._figi = newValue}
  }

  ///Глубина стакана.
  public var depth: Int32 {
    get {return _storage._depth}
    set {_uniqueStorage()._depth = newValue}
  }

  ///Множество пар значений на покупку.
  public var bids: [Order] {
    get {return _storage._bids}
    set {_uniqueStorage()._bids = newValue}
  }

  ///Множество пар значений на продажу.
  public var asks: [Order] {
    get {return _storage._asks}
    set {_uniqueStorage()._asks = newValue}
  }

  ///Цена последней сделки за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var lastPrice: Quotation {
    get {return _storage._lastPrice ?? Quotation()}
    set {_uniqueStorage()._lastPrice = newValue}
  }
  /// Returns true if `lastPrice` has been explicitly set.
  public var hasLastPrice: Bool {return _storage._lastPrice != nil}
  /// Clears the value of `lastPrice`. Subsequent reads from it will return its default value.
  public mutating func clearLastPrice() {_uniqueStorage()._lastPrice = nil}

  ///Цена закрытия за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var closePrice: Quotation {
    get {return _storage._closePrice ?? Quotation()}
    set {_uniqueStorage()._closePrice = newValue}
  }
  /// Returns true if `closePrice` has been explicitly set.
  public var hasClosePrice: Bool {return _storage._closePrice != nil}
  /// Clears the value of `closePrice`. Subsequent reads from it will return its default value.
  public mutating func clearClosePrice() {_uniqueStorage()._closePrice = nil}

  ///Верхний лимит цены за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var limitUp: Quotation {
    get {return _storage._limitUp ?? Quotation()}
    set {_uniqueStorage()._limitUp = newValue}
  }
  /// Returns true if `limitUp` has been explicitly set.
  public var hasLimitUp: Bool {return _storage._limitUp != nil}
  /// Clears the value of `limitUp`. Subsequent reads from it will return its default value.
  public mutating func clearLimitUp() {_uniqueStorage()._limitUp = nil}

  ///Нижний лимит цены за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
  public var limitDown: Quotation {
    get {return _storage._limitDown ?? Quotation()}
    set {_uniqueStorage()._limitDown = newValue}
  }
  /// Returns true if `limitDown` has been explicitly set.
  public var hasLimitDown: Bool {return _storage._limitDown != nil}
  /// Clears the value of `limitDown`. Subsequent reads from it will return its default value.
  public mutating func clearLimitDown() {_uniqueStorage()._limitDown = nil}

  ///Время получения цены последней сделки.
  public var lastPriceTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastPriceTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastPriceTs = newValue}
  }
  /// Returns true if `lastPriceTs` has been explicitly set.
  public var hasLastPriceTs: Bool {return _storage._lastPriceTs != nil}
  /// Clears the value of `lastPriceTs`. Subsequent reads from it will return its default value.
  public mutating func clearLastPriceTs() {_uniqueStorage()._lastPriceTs = nil}

  ///Время получения цены закрытия.
  public var closePriceTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._closePriceTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._closePriceTs = newValue}
  }
  /// Returns true if `closePriceTs` has been explicitly set.
  public var hasClosePriceTs: Bool {return _storage._closePriceTs != nil}
  /// Clears the value of `closePriceTs`. Subsequent reads from it will return its default value.
  public mutating func clearClosePriceTs() {_uniqueStorage()._closePriceTs = nil}

  ///Время формирования стакана на бирже.
  public var orderbookTs: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._orderbookTs ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._orderbookTs = newValue}
  }
  /// Returns true if `orderbookTs` has been explicitly set.
  public var hasOrderbookTs: Bool {return _storage._orderbookTs != nil}
  /// Clears the value of `orderbookTs`. Subsequent reads from it will return its default value.
  public mutating func clearOrderbookTs() {_uniqueStorage()._orderbookTs = nil}

  ///UID инструмента.
  public var instrumentUid: String {
    get {return _storage._instrumentUid}
    set {_uniqueStorage()._instrumentUid = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///Запрос получения торгового статуса.
public struct GetTradingStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var figi: String {
    get {return _figi ?? String()}
    set {_figi = newValue}
  }
  /// Returns true if `figi` has been explicitly set.
  public var hasFigi: Bool {return self._figi != nil}
  /// Clears the value of `figi`. Subsequent reads from it will return its default value.
  public mutating func clearFigi() {self._figi = nil}

  ///Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`.
  public var instrumentID: String {
    get {return _instrumentID ?? String()}
    set {_instrumentID = newValue}
  }
  /// Returns true if `instrumentID` has been explicitly set.
  public var hasInstrumentID: Bool {return self._instrumentID != nil}
  /// Clears the value of `instrumentID`. Subsequent reads from it will return its default value.
  public mutating func clearInstrumentID() {self._instrumentID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _figi: String? = nil
  fileprivate var _instrumentID: String? = nil
}

///Запрос получения торгового статуса.
public struct GetTradingStatusesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`.
  public var instrumentID: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о торговом статусе.
public struct GetTradingStatusesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив информации о торговых статусах.
  public var tradingStatuses: [GetTradingStatusResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Информация о торговом статусе.
public struct GetTradingStatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///FIGI-идентификатор инструмента.
  public var figi: String = String()

  ///Статус торговли инструментом.
  public var tradingStatus: SecurityTradingStatus = .unspecified

  ///Признак доступности выставления лимитной заявки по инструменту.
  public var limitOrderAvailableFlag: Bool = false

  ///Признак доступности выставления рыночной заявки по инструменту.
  public var marketOrderAvailableFlag: Bool = false

  ///Признак доступности торгов через API.
  public var apiTradeAvailableFlag: Bool = false

  ///UID инструмента.
  public var instrumentUid: String = String()

  ///Признак доступности завяки по лучшей цене.
  public var bestpriceOrderAvailableFlag: Bool = false

  ///Признак доступности только заявки по лучшей цене.
  public var onlyBestPrice: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос обезличенных сделок за последний час.
public struct GetLastTradesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var figi: String {
    get {return _figi ?? String()}
    set {_figi = newValue}
  }
  /// Returns true if `figi` has been explicitly set.
  public var hasFigi: Bool {return self._figi != nil}
  /// Clears the value of `figi`. Subsequent reads from it will return its default value.
  public mutating func clearFigi() {self._figi = nil}

  ///Начало запрашиваемого периода по UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание запрашиваемого периода по UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  ///Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`.
  public var instrumentID: String {
    get {return _instrumentID ?? String()}
    set {_instrumentID = newValue}
  }
  /// Returns true if `instrumentID` has been explicitly set.
  public var hasInstrumentID: Bool {return self._instrumentID != nil}
  /// Clears the value of `instrumentID`. Subsequent reads from it will return its default value.
  public mutating func clearInstrumentID() {self._instrumentID = nil}

  ///Тип источника сделок. Значение по умолчанию — `TRADE_SOURCE_ALL`, все сделки.
  public var tradeSource: TradeSourceType = .tradeSourceUnspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _figi: String? = nil
  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _instrumentID: String? = nil
}

///Обезличенных сделок за последний час.
public struct GetLastTradesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив сделок.
  public var trades: [Trade] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос активных подписок. Возвращает по одному сообщению на каждый тип активных подписок — `SubscribeLastPriceResponse`, `SubscribeInfoResponse`, `SubscribeTradesResponse`, `SubscribeOrderBookResponse`, `SubscribeCandlesResponse`.
public struct GetMySubscriptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Запрос цен закрытия торговой сессии по инструментам.
public struct GetClosePricesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив по инструментам.
  public var instruments: [InstrumentClosePriceRequest] = []

  ///Статус запрашиваемых инструментов. [Возможные значения](#instrumentstatus).
  public var instrumentStatus: InstrumentStatus {
    get {return _instrumentStatus ?? .unspecified}
    set {_instrumentStatus = newValue}
  }
  /// Returns true if `instrumentStatus` has been explicitly set.
  public var hasInstrumentStatus: Bool {return self._instrumentStatus != nil}
  /// Clears the value of `instrumentStatus`. Subsequent reads from it will return its default value.
  public mutating func clearInstrumentStatus() {self._instrumentStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrumentStatus: InstrumentStatus? = nil
}

///Запрос цен закрытия торговой сессии по инструменту.
public struct InstrumentClosePriceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`.
  public var instrumentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Цены закрытия торговой сессии по инструментам.
public struct GetClosePricesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив по инструментам.
  public var closePrices: [InstrumentClosePriceResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///Цена закрытия торговой сессии по инструменту.
public struct InstrumentClosePriceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///FIGI инструмента.
  public var figi: String = String()

  ///UID инструмента.
  public var instrumentUid: String = String()

  ///Цена закрытия торговой сессии.
  public var price: Quotation {
    get {return _price ?? Quotation()}
    set {_price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return self._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {self._price = nil}

  ///Цена последней сделки с вечерней сессии. Цена публикуется биржей по торговым дням и в нерабочие дни не обновляется.
  public var eveningSessionPrice: Quotation {
    get {return _eveningSessionPrice ?? Quotation()}
    set {_eveningSessionPrice = newValue}
  }
  /// Returns true if `eveningSessionPrice` has been explicitly set.
  public var hasEveningSessionPrice: Bool {return self._eveningSessionPrice != nil}
  /// Clears the value of `eveningSessionPrice`. Subsequent reads from it will return its default value.
  public mutating func clearEveningSessionPrice() {self._eveningSessionPrice = nil}

  ///Дата совершения торгов.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  ///Дата цены закрытия вечерней сессии.
  public var eveningSessionPriceTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _eveningSessionPriceTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_eveningSessionPriceTime = newValue}
  }
  /// Returns true if `eveningSessionPriceTime` has been explicitly set.
  public var hasEveningSessionPriceTime: Bool {return self._eveningSessionPriceTime != nil}
  /// Clears the value of `eveningSessionPriceTime`. Subsequent reads from it will return its default value.
  public mutating func clearEveningSessionPriceTime() {self._eveningSessionPriceTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _price: Quotation? = nil
  fileprivate var _eveningSessionPrice: Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _eveningSessionPriceTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct GetTechAnalysisRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Тип технического индикатора.
  public var indicatorType: GetTechAnalysisRequest.IndicatorType = .unspecified

  ///UID инструмента.
  public var instrumentUid: String = String()

  ///Начало запрашиваемого периода по UTC.
  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  ///Окончание запрашиваемого периода по UTC.
  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {self._to = nil}

  ///Интервал, за который рассчитывается индикатор.
  public var interval: GetTechAnalysisRequest.IndicatorInterval = .unspecified

  ///Тип цены, который используется при расчете индикатора.
  public var typeOfPrice: GetTechAnalysisRequest.TypeOfPrice = .unspecified

  ///Торговый период, за который рассчитывается индикатор.
  public var length: Int32 = 0

  ///Параметры отклонения.
  public var deviation: GetTechAnalysisRequest.Deviation {
    get {return _deviation ?? GetTechAnalysisRequest.Deviation()}
    set {_deviation = newValue}
  }
  /// Returns true if `deviation` has been explicitly set.
  public var hasDeviation: Bool {return self._deviation != nil}
  /// Clears the value of `deviation`. Subsequent reads from it will return its default value.
  public mutating func clearDeviation() {self._deviation = nil}

  ///Параметры сглаживания.
  public var smoothing: GetTechAnalysisRequest.Smoothing {
    get {return _smoothing ?? GetTechAnalysisRequest.Smoothing()}
    set {_smoothing = newValue}
  }
  /// Returns true if `smoothing` has been explicitly set.
  public var hasSmoothing: Bool {return self._smoothing != nil}
  /// Clears the value of `smoothing`. Subsequent reads from it will return its default value.
  public mutating func clearSmoothing() {self._smoothing = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///Интервал свечи.
  public enum IndicatorInterval: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    ///Интервал не определен.
    case unspecified // = 0

    ///1 минута.
    case oneMinute // = 1

    ///5 минут.
    case fiveMinutes // = 2

    ///15 минут.
    case fifteenMinutes // = 3

    ///1 час.
    case oneHour // = 4

    ///1 день.
    case oneDay // = 5

    ///2 минуты.
    case indicatorInterval2Min // = 6

    ///3 минуты.
    case indicatorInterval3Min // = 7

    ///10 минут.
    case indicatorInterval10Min // = 8

    ///30 минут.
    case indicatorInterval30Min // = 9

    ///2 часа.
    case indicatorInterval2Hour // = 10

    ///4 часа.
    case indicatorInterval4Hour // = 11

    ///Неделя.
    case week // = 12

    ///Месяц.
    case month // = 13
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .oneMinute
      case 2: self = .fiveMinutes
      case 3: self = .fifteenMinutes
      case 4: self = .oneHour
      case 5: self = .oneDay
      case 6: self = .indicatorInterval2Min
      case 7: self = .indicatorInterval3Min
      case 8: self = .indicatorInterval10Min
      case 9: self = .indicatorInterval30Min
      case 10: self = .indicatorInterval2Hour
      case 11: self = .indicatorInterval4Hour
      case 12: self = .week
      case 13: self = .month
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .oneMinute: return 1
      case .fiveMinutes: return 2
      case .fifteenMinutes: return 3
      case .oneHour: return 4
      case .oneDay: return 5
      case .indicatorInterval2Min: return 6
      case .indicatorInterval3Min: return 7
      case .indicatorInterval10Min: return 8
      case .indicatorInterval30Min: return 9
      case .indicatorInterval2Hour: return 10
      case .indicatorInterval4Hour: return 11
      case .week: return 12
      case .month: return 13
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [GetTechAnalysisRequest.IndicatorInterval] = [
      .unspecified,
      .oneMinute,
      .fiveMinutes,
      .fifteenMinutes,
      .oneHour,
      .oneDay,
      .indicatorInterval2Min,
      .indicatorInterval3Min,
      .indicatorInterval10Min,
      .indicatorInterval30Min,
      .indicatorInterval2Hour,
      .indicatorInterval4Hour,
      .week,
      .month,
    ]

  }

  public enum TypeOfPrice: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    ///Не указано.
    case unspecified // = 0

    ///Цена закрытия.
    case close // = 1

    ///Цена открытия.
    case `open` // = 2

    ///Максимальное значение за выбранный интервал.
    case high // = 3

    ///Минимальное значение за выбранный интервал.
    case low // = 4

    ///Среднее значение по показателям [ (close + open + high + low) / 4 ].
    case avg // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .close
      case 2: self = .open
      case 3: self = .high
      case 4: self = .low
      case 5: self = .avg
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .close: return 1
      case .open: return 2
      case .high: return 3
      case .low: return 4
      case .avg: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [GetTechAnalysisRequest.TypeOfPrice] = [
      .unspecified,
      .close,
      .open,
      .high,
      .low,
      .avg,
    ]

  }

  public enum IndicatorType: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    ///Не определен.
    case unspecified // = 0

    ///Bollinger Bands — линия Боллинжера.
    case bb // = 1

    ///Exponential Moving Average — EMA, экспоненциальная скользящая средняя.
    case ema // = 2

    ///Relative Strength Index — индекс относительной силы.
    case rsi // = 3

    ///Moving Average Convergence/Divergence — схождение/расхождение скользящих средних.
    case macd // = 4

    ///Simple Moving Average — простое скользящее среднее.
    case sma // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .bb
      case 2: self = .ema
      case 3: self = .rsi
      case 4: self = .macd
      case 5: self = .sma
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .bb: return 1
      case .ema: return 2
      case .rsi: return 3
      case .macd: return 4
      case .sma: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [GetTechAnalysisRequest.IndicatorType] = [
      .unspecified,
      .bb,
      .ema,
      .rsi,
      .macd,
      .sma,
    ]

  }

  public struct Smoothing: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///Короткий период сглаживания для первой экспоненциальной скользящей средней (EMA).
    public var fastLength: Int32 = 0

    ///Длинный период сглаживания для второй экспоненциальной скользящей средней (EMA).
    public var slowLength: Int32 = 0

    ///Период сглаживания для третьей экспоненциальной скользящей средней (EMA)
    public var signalSmoothing: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Deviation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///Количество стандартных отклонений, на которые отступают верхняя и нижняя границы.
    public var deviationMultiplier: Quotation {
      get {return _deviationMultiplier ?? Quotation()}
      set {_deviationMultiplier = newValue}
    }
    /// Returns true if `deviationMultiplier` has been explicitly set.
    public var hasDeviationMultiplier: Bool {return self._deviationMultiplier != nil}
    /// Clears the value of `deviationMultiplier`. Subsequent reads from it will return its default value.
    public mutating func clearDeviationMultiplier() {self._deviationMultiplier = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _deviationMultiplier: Quotation? = nil
  }

  public init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _deviation: GetTechAnalysisRequest.Deviation? = nil
  fileprivate var _smoothing: GetTechAnalysisRequest.Smoothing? = nil
}

public struct GetTechAnalysisResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив значений результатов технического анализа.
  public var technicalIndicators: [GetTechAnalysisResponse.TechAnalysisItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct TechAnalysisItem: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///Временная метка по UTC, для которой были рассчитаны значения индикатора.
    public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    public var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    public mutating func clearTimestamp() {self._timestamp = nil}

    ///Значение простого скользящего среднего (средней линии).
    public var middleBand: Quotation {
      get {return _middleBand ?? Quotation()}
      set {_middleBand = newValue}
    }
    /// Returns true if `middleBand` has been explicitly set.
    public var hasMiddleBand: Bool {return self._middleBand != nil}
    /// Clears the value of `middleBand`. Subsequent reads from it will return its default value.
    public mutating func clearMiddleBand() {self._middleBand = nil}

    ///Значение верхней линии Боллинджера.
    public var upperBand: Quotation {
      get {return _upperBand ?? Quotation()}
      set {_upperBand = newValue}
    }
    /// Returns true if `upperBand` has been explicitly set.
    public var hasUpperBand: Bool {return self._upperBand != nil}
    /// Clears the value of `upperBand`. Subsequent reads from it will return its default value.
    public mutating func clearUpperBand() {self._upperBand = nil}

    ///Значение нижней линии Боллинджера.
    public var lowerBand: Quotation {
      get {return _lowerBand ?? Quotation()}
      set {_lowerBand = newValue}
    }
    /// Returns true if `lowerBand` has been explicitly set.
    public var hasLowerBand: Bool {return self._lowerBand != nil}
    /// Clears the value of `lowerBand`. Subsequent reads from it will return its default value.
    public mutating func clearLowerBand() {self._lowerBand = nil}

    ///Значение сигнальной линии.
    public var signal: Quotation {
      get {return _signal ?? Quotation()}
      set {_signal = newValue}
    }
    /// Returns true if `signal` has been explicitly set.
    public var hasSignal: Bool {return self._signal != nil}
    /// Clears the value of `signal`. Subsequent reads from it will return its default value.
    public mutating func clearSignal() {self._signal = nil}

    ///Значение линии MACD.
    public var macd: Quotation {
      get {return _macd ?? Quotation()}
      set {_macd = newValue}
    }
    /// Returns true if `macd` has been explicitly set.
    public var hasMacd: Bool {return self._macd != nil}
    /// Clears the value of `macd`. Subsequent reads from it will return its default value.
    public mutating func clearMacd() {self._macd = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _middleBand: Quotation? = nil
    fileprivate var _upperBand: Quotation? = nil
    fileprivate var _lowerBand: Quotation? = nil
    fileprivate var _signal: Quotation? = nil
    fileprivate var _macd: Quotation? = nil
  }

  public init() {}
}

public struct GetMarketValuesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив идентификаторов инструментов.
  public var instrumentID: [String] = []

  ///Массив запрашиваемых параметров.
  public var values: [MarketValueType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetMarketValuesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Массив значений параметров.
  public var instruments: [MarketValueInstrument] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MarketValueInstrument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Идентификатор инструмента.
  public var instrumentUid: String = String()

  ///Массив параметров инструмента.
  public var values: [MarketValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MarketValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Тип параметра.
  public var type: MarketValueType {
    get {return _type ?? .instrumentValueUnspecified}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  ///Значение.
  public var value: Quotation {
    get {return _value ?? Quotation()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  ///Дата и время.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _type: MarketValueType? = nil
  fileprivate var _value: Quotation? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tinkoff.public.invest.api.contract.v1"

extension SubscriptionAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_ACTION_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_ACTION_SUBSCRIBE"),
    2: .same(proto: "SUBSCRIPTION_ACTION_UNSUBSCRIBE"),
  ]
}

extension SubscriptionInterval: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_INTERVAL_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_INTERVAL_ONE_MINUTE"),
    2: .same(proto: "SUBSCRIPTION_INTERVAL_FIVE_MINUTES"),
    3: .same(proto: "SUBSCRIPTION_INTERVAL_FIFTEEN_MINUTES"),
    4: .same(proto: "SUBSCRIPTION_INTERVAL_ONE_HOUR"),
    5: .same(proto: "SUBSCRIPTION_INTERVAL_ONE_DAY"),
    6: .same(proto: "SUBSCRIPTION_INTERVAL_2_MIN"),
    7: .same(proto: "SUBSCRIPTION_INTERVAL_3_MIN"),
    8: .same(proto: "SUBSCRIPTION_INTERVAL_10_MIN"),
    9: .same(proto: "SUBSCRIPTION_INTERVAL_30_MIN"),
    10: .same(proto: "SUBSCRIPTION_INTERVAL_2_HOUR"),
    11: .same(proto: "SUBSCRIPTION_INTERVAL_4_HOUR"),
    12: .same(proto: "SUBSCRIPTION_INTERVAL_WEEK"),
    13: .same(proto: "SUBSCRIPTION_INTERVAL_MONTH"),
  ]
}

extension SubscriptionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_STATUS_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_STATUS_SUCCESS"),
    2: .same(proto: "SUBSCRIPTION_STATUS_INSTRUMENT_NOT_FOUND"),
    3: .same(proto: "SUBSCRIPTION_STATUS_SUBSCRIPTION_ACTION_IS_INVALID"),
    4: .same(proto: "SUBSCRIPTION_STATUS_DEPTH_IS_INVALID"),
    5: .same(proto: "SUBSCRIPTION_STATUS_INTERVAL_IS_INVALID"),
    6: .same(proto: "SUBSCRIPTION_STATUS_LIMIT_IS_EXCEEDED"),
    7: .same(proto: "SUBSCRIPTION_STATUS_INTERNAL_ERROR"),
    8: .same(proto: "SUBSCRIPTION_STATUS_TOO_MANY_REQUESTS"),
    9: .same(proto: "SUBSCRIPTION_STATUS_SUBSCRIPTION_NOT_FOUND"),
    10: .same(proto: "SUBSCRIPTION_STATUS_SOURCE_IS_INVALID"),
  ]
}

extension TradeSourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRADE_SOURCE_UNSPECIFIED"),
    1: .same(proto: "TRADE_SOURCE_EXCHANGE"),
    2: .same(proto: "TRADE_SOURCE_DEALER"),
    3: .same(proto: "TRADE_SOURCE_ALL"),
  ]
}

extension TradeDirection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRADE_DIRECTION_UNSPECIFIED"),
    1: .same(proto: "TRADE_DIRECTION_BUY"),
    2: .same(proto: "TRADE_DIRECTION_SELL"),
  ]
}

extension CandleInterval: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CANDLE_INTERVAL_UNSPECIFIED"),
    1: .same(proto: "CANDLE_INTERVAL_1_MIN"),
    2: .same(proto: "CANDLE_INTERVAL_5_MIN"),
    3: .same(proto: "CANDLE_INTERVAL_15_MIN"),
    4: .same(proto: "CANDLE_INTERVAL_HOUR"),
    5: .same(proto: "CANDLE_INTERVAL_DAY"),
    6: .same(proto: "CANDLE_INTERVAL_2_MIN"),
    7: .same(proto: "CANDLE_INTERVAL_3_MIN"),
    8: .same(proto: "CANDLE_INTERVAL_10_MIN"),
    9: .same(proto: "CANDLE_INTERVAL_30_MIN"),
    10: .same(proto: "CANDLE_INTERVAL_2_HOUR"),
    11: .same(proto: "CANDLE_INTERVAL_4_HOUR"),
    12: .same(proto: "CANDLE_INTERVAL_WEEK"),
    13: .same(proto: "CANDLE_INTERVAL_MONTH"),
    14: .same(proto: "CANDLE_INTERVAL_5_SEC"),
    15: .same(proto: "CANDLE_INTERVAL_10_SEC"),
    16: .same(proto: "CANDLE_INTERVAL_30_SEC"),
  ]
}

extension CandleSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CANDLE_SOURCE_UNSPECIFIED"),
    1: .same(proto: "CANDLE_SOURCE_EXCHANGE"),
    2: .same(proto: "CANDLE_SOURCE_DEALER_WEEKEND"),
  ]
}

extension MarketValueType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSTRUMENT_VALUE_UNSPECIFIED"),
    1: .same(proto: "INSTRUMENT_VALUE_LAST_PRICE"),
    2: .same(proto: "INSTRUMENT_VALUE_LAST_PRICE_DEALER"),
    3: .same(proto: "INSTRUMENT_VALUE_CLOSE_PRICE"),
    4: .same(proto: "INSTRUMENT_VALUE_EVENING_SESSION_PRICE"),
    5: .same(proto: "INSTRUMENT_VALUE_OPEN_INTEREST"),
  ]
}

extension OrderBookType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDERBOOK_TYPE_UNSPECIFIED"),
    1: .same(proto: "ORDERBOOK_TYPE_EXCHANGE"),
    2: .same(proto: "ORDERBOOK_TYPE_DEALER"),
    3: .same(proto: "ORDERBOOK_TYPE_ALL"),
  ]
}

extension LastPriceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LAST_PRICE_UNSPECIFIED"),
    1: .same(proto: "LAST_PRICE_EXCHANGE"),
    2: .same(proto: "LAST_PRICE_DEALER"),
  ]
}

extension MarketDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketDataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscribe_candles_request"),
    2: .standard(proto: "subscribe_order_book_request"),
    3: .standard(proto: "subscribe_trades_request"),
    4: .standard(proto: "subscribe_info_request"),
    5: .standard(proto: "subscribe_last_price_request"),
    6: .standard(proto: "get_my_subscriptions"),
    7: .same(proto: "ping"),
    15: .standard(proto: "ping_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SubscribeCandlesRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeCandlesRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeCandlesRequest(v)
        }
      }()
      case 2: try {
        var v: SubscribeOrderBookRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeOrderBookRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeOrderBookRequest(v)
        }
      }()
      case 3: try {
        var v: SubscribeTradesRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeTradesRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeTradesRequest(v)
        }
      }()
      case 4: try {
        var v: SubscribeInfoRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeInfoRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeInfoRequest(v)
        }
      }()
      case 5: try {
        var v: SubscribeLastPriceRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeLastPriceRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeLastPriceRequest(v)
        }
      }()
      case 6: try {
        var v: GetMySubscriptions?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getMySubscriptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getMySubscriptions(v)
        }
      }()
      case 7: try {
        var v: PingRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ping(v)
        }
      }()
      case 15: try {
        var v: PingDelaySettings?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .pingSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .pingSettings(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .subscribeCandlesRequest?: try {
      guard case .subscribeCandlesRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .subscribeOrderBookRequest?: try {
      guard case .subscribeOrderBookRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .subscribeTradesRequest?: try {
      guard case .subscribeTradesRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .subscribeInfoRequest?: try {
      guard case .subscribeInfoRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .subscribeLastPriceRequest?: try {
      guard case .subscribeLastPriceRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .getMySubscriptions?: try {
      guard case .getMySubscriptions(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .pingSettings?: try {
      guard case .pingSettings(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MarketDataRequest, rhs: MarketDataRequest) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MarketDataServerSideStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketDataServerSideStreamRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscribe_candles_request"),
    2: .standard(proto: "subscribe_order_book_request"),
    3: .standard(proto: "subscribe_trades_request"),
    4: .standard(proto: "subscribe_info_request"),
    5: .standard(proto: "subscribe_last_price_request"),
    15: .standard(proto: "ping_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subscribeCandlesRequest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._subscribeOrderBookRequest) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._subscribeTradesRequest) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._subscribeInfoRequest) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._subscribeLastPriceRequest) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._pingSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._subscribeCandlesRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._subscribeOrderBookRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._subscribeTradesRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._subscribeInfoRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._subscribeLastPriceRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._pingSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MarketDataServerSideStreamRequest, rhs: MarketDataServerSideStreamRequest) -> Bool {
    if lhs._subscribeCandlesRequest != rhs._subscribeCandlesRequest {return false}
    if lhs._subscribeOrderBookRequest != rhs._subscribeOrderBookRequest {return false}
    if lhs._subscribeTradesRequest != rhs._subscribeTradesRequest {return false}
    if lhs._subscribeInfoRequest != rhs._subscribeInfoRequest {return false}
    if lhs._subscribeLastPriceRequest != rhs._subscribeLastPriceRequest {return false}
    if lhs._pingSettings != rhs._pingSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MarketDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketDataResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscribe_candles_response"),
    2: .standard(proto: "subscribe_order_book_response"),
    3: .standard(proto: "subscribe_trades_response"),
    4: .standard(proto: "subscribe_info_response"),
    5: .same(proto: "candle"),
    6: .same(proto: "trade"),
    7: .same(proto: "orderbook"),
    8: .standard(proto: "trading_status"),
    9: .same(proto: "ping"),
    10: .standard(proto: "subscribe_last_price_response"),
    11: .standard(proto: "last_price"),
    12: .standard(proto: "open_interest"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SubscribeCandlesResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeCandlesResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeCandlesResponse(v)
        }
      }()
      case 2: try {
        var v: SubscribeOrderBookResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeOrderBookResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeOrderBookResponse(v)
        }
      }()
      case 3: try {
        var v: SubscribeTradesResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeTradesResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeTradesResponse(v)
        }
      }()
      case 4: try {
        var v: SubscribeInfoResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeInfoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeInfoResponse(v)
        }
      }()
      case 5: try {
        var v: Candle?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .candle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .candle(v)
        }
      }()
      case 6: try {
        var v: Trade?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .trade(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .trade(v)
        }
      }()
      case 7: try {
        var v: OrderBook?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .orderbook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .orderbook(v)
        }
      }()
      case 8: try {
        var v: TradingStatus?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .tradingStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .tradingStatus(v)
        }
      }()
      case 9: try {
        var v: Ping?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ping(v)
        }
      }()
      case 10: try {
        var v: SubscribeLastPriceResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .subscribeLastPriceResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .subscribeLastPriceResponse(v)
        }
      }()
      case 11: try {
        var v: LastPrice?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .lastPrice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .lastPrice(v)
        }
      }()
      case 12: try {
        var v: OpenInterest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .openInterest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .openInterest(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .subscribeCandlesResponse?: try {
      guard case .subscribeCandlesResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .subscribeOrderBookResponse?: try {
      guard case .subscribeOrderBookResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .subscribeTradesResponse?: try {
      guard case .subscribeTradesResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .subscribeInfoResponse?: try {
      guard case .subscribeInfoResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .candle?: try {
      guard case .candle(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .trade?: try {
      guard case .trade(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .orderbook?: try {
      guard case .orderbook(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .tradingStatus?: try {
      guard case .tradingStatus(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .subscribeLastPriceResponse?: try {
      guard case .subscribeLastPriceResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .lastPrice?: try {
      guard case .lastPrice(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .openInterest?: try {
      guard case .openInterest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MarketDataResponse, rhs: MarketDataResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeCandlesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeCandlesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
    3: .standard(proto: "waiting_close"),
    9: .standard(proto: "candle_source_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.waitingClose) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self._candleSourceType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    if self.waitingClose != false {
      try visitor.visitSingularBoolField(value: self.waitingClose, fieldNumber: 3)
    }
    try { if let v = self._candleSourceType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeCandlesRequest, rhs: SubscribeCandlesRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.waitingClose != rhs.waitingClose {return false}
    if lhs._candleSourceType != rhs._candleSourceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CandleInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandleInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "interval"),
    3: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 2)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CandleInstrument, rhs: CandleInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeCandlesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeCandlesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "candles_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.candlesSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.candlesSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.candlesSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeCandlesResponse, rhs: SubscribeCandlesResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.candlesSubscriptions != rhs.candlesSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CandleSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandleSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "interval"),
    3: .standard(proto: "subscription_status"),
    4: .standard(proto: "instrument_uid"),
    5: .standard(proto: "waiting_close"),
    6: .standard(proto: "stream_id"),
    7: .standard(proto: "subscription_id"),
    8: .standard(proto: "subscription_action"),
    9: .standard(proto: "candle_source_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.waitingClose) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self._candleSourceType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 2)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 3)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 4)
    }
    if self.waitingClose != false {
      try visitor.visitSingularBoolField(value: self.waitingClose, fieldNumber: 5)
    }
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 6)
    }
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 7)
    }
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 8)
    }
    try { if let v = self._candleSourceType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CandleSubscription, rhs: CandleSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.waitingClose != rhs.waitingClose {return false}
    if lhs.streamID != rhs.streamID {return false}
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs._candleSourceType != rhs._candleSourceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeOrderBookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeOrderBookRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeOrderBookRequest, rhs: SubscribeOrderBookRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderBookInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBookInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "instrument_id"),
    4: .standard(proto: "order_book_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.orderBookType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 3)
    }
    if self.orderBookType != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderBookType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrderBookInstrument, rhs: OrderBookInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.orderBookType != rhs.orderBookType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeOrderBookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeOrderBookResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "order_book_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.orderBookSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.orderBookSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orderBookSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeOrderBookResponse, rhs: SubscribeOrderBookResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.orderBookSubscriptions != rhs.orderBookSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderBookSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBookSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "subscription_status"),
    4: .standard(proto: "instrument_uid"),
    5: .standard(proto: "stream_id"),
    6: .standard(proto: "subscription_id"),
    7: .standard(proto: "order_book_type"),
    8: .standard(proto: "subscription_action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.orderBookType) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 3)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 4)
    }
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 5)
    }
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 6)
    }
    if self.orderBookType != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderBookType, fieldNumber: 7)
    }
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrderBookSubscription, rhs: OrderBookSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.streamID != rhs.streamID {return false}
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.orderBookType != rhs.orderBookType {return false}
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeTradesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeTradesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
    3: .standard(proto: "trade_source"),
    4: .standard(proto: "with_open_interest"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.tradeSource) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.withOpenInterest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    if self.tradeSource != .tradeSourceUnspecified {
      try visitor.visitSingularEnumField(value: self.tradeSource, fieldNumber: 3)
    }
    if self.withOpenInterest != false {
      try visitor.visitSingularBoolField(value: self.withOpenInterest, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeTradesRequest, rhs: SubscribeTradesRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.tradeSource != rhs.tradeSource {return false}
    if lhs.withOpenInterest != rhs.withOpenInterest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradeInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradeInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradeInstrument, rhs: TradeInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeTradesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeTradesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "trade_subscriptions"),
    3: .standard(proto: "trade_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tradeSubscriptions) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.tradeSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.tradeSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tradeSubscriptions, fieldNumber: 2)
    }
    if self.tradeSource != .tradeSourceUnspecified {
      try visitor.visitSingularEnumField(value: self.tradeSource, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeTradesResponse, rhs: SubscribeTradesResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.tradeSubscriptions != rhs.tradeSubscriptions {return false}
    if lhs.tradeSource != rhs.tradeSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradeSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradeSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "subscription_status"),
    3: .standard(proto: "instrument_uid"),
    4: .standard(proto: "stream_id"),
    5: .standard(proto: "subscription_id"),
    6: .standard(proto: "with_open_interest"),
    7: .standard(proto: "subscription_action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.withOpenInterest) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 2)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 3)
    }
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 4)
    }
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 5)
    }
    if self.withOpenInterest != false {
      try visitor.visitSingularBoolField(value: self.withOpenInterest, fieldNumber: 6)
    }
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradeSubscription, rhs: TradeSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.streamID != rhs.streamID {return false}
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.withOpenInterest != rhs.withOpenInterest {return false}
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeInfoRequest, rhs: SubscribeInfoRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InfoInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InfoInstrument, rhs: InfoInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "info_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.infoSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.infoSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infoSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeInfoResponse, rhs: SubscribeInfoResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.infoSubscriptions != rhs.infoSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InfoSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "subscription_status"),
    3: .standard(proto: "instrument_uid"),
    4: .standard(proto: "stream_id"),
    5: .standard(proto: "subscription_id"),
    6: .standard(proto: "subscription_action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 2)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 3)
    }
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 4)
    }
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 5)
    }
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InfoSubscription, rhs: InfoSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.streamID != rhs.streamID {return false}
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeLastPriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeLastPriceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_action"),
    2: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 1)
    }
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeLastPriceRequest, rhs: SubscribeLastPriceRequest) -> Bool {
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LastPriceInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastPriceInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LastPriceInstrument, rhs: LastPriceInstrument) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeLastPriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeLastPriceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tracking_id"),
    2: .standard(proto: "last_price_subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackingID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.lastPriceSubscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackingID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackingID, fieldNumber: 1)
    }
    if !self.lastPriceSubscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lastPriceSubscriptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubscribeLastPriceResponse, rhs: SubscribeLastPriceResponse) -> Bool {
    if lhs.trackingID != rhs.trackingID {return false}
    if lhs.lastPriceSubscriptions != rhs.lastPriceSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LastPriceSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastPriceSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "subscription_status"),
    3: .standard(proto: "instrument_uid"),
    4: .standard(proto: "stream_id"),
    5: .standard(proto: "subscription_id"),
    6: .standard(proto: "subscription_action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscriptionStatus) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.subscriptionAction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.subscriptionStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionStatus, fieldNumber: 2)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 3)
    }
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 4)
    }
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 5)
    }
    if self.subscriptionAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriptionAction, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LastPriceSubscription, rhs: LastPriceSubscription) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.subscriptionStatus != rhs.subscriptionStatus {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.streamID != rhs.streamID {return false}
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.subscriptionAction != rhs.subscriptionAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Candle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Candle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "interval"),
    3: .same(proto: "open"),
    4: .same(proto: "high"),
    5: .same(proto: "low"),
    6: .same(proto: "close"),
    7: .same(proto: "volume"),
    8: .same(proto: "time"),
    9: .standard(proto: "last_trade_ts"),
    10: .standard(proto: "instrument_uid"),
    19: .standard(proto: "candle_source_type"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _interval: SubscriptionInterval = .unspecified
    var _open: Quotation? = nil
    var _high: Quotation? = nil
    var _low: Quotation? = nil
    var _close: Quotation? = nil
    var _volume: Int64 = 0
    var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastTradeTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _instrumentUid: String = String()
    var _candleSourceType: CandleSource = .unspecified

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _interval = source._interval
      _open = source._open
      _high = source._high
      _low = source._low
      _close = source._close
      _volume = source._volume
      _time = source._time
      _lastTradeTs = source._lastTradeTs
      _instrumentUid = source._instrumentUid
      _candleSourceType = source._candleSourceType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._interval) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._open) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._high) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._low) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._close) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._volume) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._time) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._lastTradeTs) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._instrumentUid) }()
        case 19: try { try decoder.decodeSingularEnumField(value: &_storage._candleSourceType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if _storage._interval != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._interval, fieldNumber: 2)
      }
      try { if let v = _storage._open {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._high {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._low {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._close {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._volume != 0 {
        try visitor.visitSingularInt64Field(value: _storage._volume, fieldNumber: 7)
      }
      try { if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._lastTradeTs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._instrumentUid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentUid, fieldNumber: 10)
      }
      if _storage._candleSourceType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._candleSourceType, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Candle, rhs: Candle) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._interval != rhs_storage._interval {return false}
        if _storage._open != rhs_storage._open {return false}
        if _storage._high != rhs_storage._high {return false}
        if _storage._low != rhs_storage._low {return false}
        if _storage._close != rhs_storage._close {return false}
        if _storage._volume != rhs_storage._volume {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._lastTradeTs != rhs_storage._lastTradeTs {return false}
        if _storage._instrumentUid != rhs_storage._instrumentUid {return false}
        if _storage._candleSourceType != rhs_storage._candleSourceType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderBook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "is_consistent"),
    4: .same(proto: "bids"),
    5: .same(proto: "asks"),
    6: .same(proto: "time"),
    7: .standard(proto: "limit_up"),
    8: .standard(proto: "limit_down"),
    9: .standard(proto: "instrument_uid"),
    10: .standard(proto: "order_book_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isConsistent) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.bids) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.asks) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._limitUp) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._limitDown) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.orderBookType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    if self.isConsistent != false {
      try visitor.visitSingularBoolField(value: self.isConsistent, fieldNumber: 3)
    }
    if !self.bids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bids, fieldNumber: 4)
    }
    if !self.asks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.asks, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._limitUp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._limitDown {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 9)
    }
    if self.orderBookType != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderBookType, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrderBook, rhs: OrderBook) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs.isConsistent != rhs.isConsistent {return false}
    if lhs.bids != rhs.bids {return false}
    if lhs.asks != rhs.asks {return false}
    if lhs._time != rhs._time {return false}
    if lhs._limitUp != rhs._limitUp {return false}
    if lhs._limitDown != rhs._limitDown {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.orderBookType != rhs.orderBookType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Order"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "quantity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order, rhs: Order) -> Bool {
    if lhs._price != rhs._price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Trade: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Trade"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "direction"),
    3: .same(proto: "price"),
    4: .same(proto: "quantity"),
    5: .same(proto: "time"),
    6: .standard(proto: "instrument_uid"),
    7: .standard(proto: "trade_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.quantity) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.tradeSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.direction != .unspecified {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 2)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 4)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 6)
    }
    if self.tradeSource != .tradeSourceUnspecified {
      try visitor.visitSingularEnumField(value: self.tradeSource, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Trade, rhs: Trade) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs._price != rhs._price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs._time != rhs._time {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.tradeSource != rhs.tradeSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradingStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TradingStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "trading_status"),
    3: .same(proto: "time"),
    4: .standard(proto: "limit_order_available_flag"),
    5: .standard(proto: "market_order_available_flag"),
    6: .standard(proto: "instrument_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.tradingStatus) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.limitOrderAvailableFlag) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.marketOrderAvailableFlag) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.tradingStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.tradingStatus, fieldNumber: 2)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.limitOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.limitOrderAvailableFlag, fieldNumber: 4)
    }
    if self.marketOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.marketOrderAvailableFlag, fieldNumber: 5)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TradingStatus, rhs: TradingStatus) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.tradingStatus != rhs.tradingStatus {return false}
    if lhs._time != rhs._time {return false}
    if lhs.limitOrderAvailableFlag != rhs.limitOrderAvailableFlag {return false}
    if lhs.marketOrderAvailableFlag != rhs.marketOrderAvailableFlag {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetCandlesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCandlesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "interval"),
    5: .standard(proto: "instrument_id"),
    7: .standard(proto: "candle_source_type"),
    10: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._instrumentID) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._candleSourceType) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._figi {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 4)
    }
    try { if let v = self._instrumentID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._candleSourceType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._limit {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetCandlesRequest, rhs: GetCandlesRequest) -> Bool {
    if lhs._figi != rhs._figi {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs._instrumentID != rhs._instrumentID {return false}
    if lhs._candleSourceType != rhs._candleSourceType {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetCandlesRequest.CandleSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CANDLE_SOURCE_UNSPECIFIED"),
    1: .same(proto: "CANDLE_SOURCE_EXCHANGE"),
    3: .same(proto: "CANDLE_SOURCE_INCLUDE_WEEKEND"),
  ]
}

extension GetCandlesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCandlesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "candles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.candles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.candles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.candles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetCandlesResponse, rhs: GetCandlesResponse) -> Bool {
    if lhs.candles != rhs.candles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HistoricCandle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoricCandle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "open"),
    2: .same(proto: "high"),
    3: .same(proto: "low"),
    4: .same(proto: "close"),
    5: .same(proto: "volume"),
    6: .same(proto: "time"),
    7: .standard(proto: "is_complete"),
    9: .standard(proto: "candle_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._open) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._high) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._low) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._close) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.volume) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isComplete) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.candleSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._open {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._high {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._low {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._close {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.volume != 0 {
      try visitor.visitSingularInt64Field(value: self.volume, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.isComplete != false {
      try visitor.visitSingularBoolField(value: self.isComplete, fieldNumber: 7)
    }
    if self.candleSource != .unspecified {
      try visitor.visitSingularEnumField(value: self.candleSource, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HistoricCandle, rhs: HistoricCandle) -> Bool {
    if lhs._open != rhs._open {return false}
    if lhs._high != rhs._high {return false}
    if lhs._low != rhs._low {return false}
    if lhs._close != rhs._close {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs._time != rhs._time {return false}
    if lhs.isComplete != rhs.isComplete {return false}
    if lhs.candleSource != rhs.candleSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetLastPricesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastPricesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_id"),
    3: .standard(proto: "last_price_type"),
    9: .standard(proto: "instrument_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.instrumentID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.lastPriceType) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self._instrumentStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitRepeatedStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.instrumentID, fieldNumber: 2)
    }
    if self.lastPriceType != .lastPriceUnspecified {
      try visitor.visitSingularEnumField(value: self.lastPriceType, fieldNumber: 3)
    }
    try { if let v = self._instrumentStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetLastPricesRequest, rhs: GetLastPricesRequest) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.lastPriceType != rhs.lastPriceType {return false}
    if lhs._instrumentStatus != rhs._instrumentStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetLastPricesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastPricesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_prices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lastPrices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastPrices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lastPrices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetLastPricesResponse, rhs: GetLastPricesResponse) -> Bool {
    if lhs.lastPrices != rhs.lastPrices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LastPrice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastPrice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "price"),
    3: .same(proto: "time"),
    11: .standard(proto: "instrument_uid"),
    12: .standard(proto: "last_price_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.lastPriceType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 11)
    }
    if self.lastPriceType != .lastPriceUnspecified {
      try visitor.visitSingularEnumField(value: self.lastPriceType, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LastPrice, rhs: LastPrice) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs._price != rhs._price {return false}
    if lhs._time != rhs._time {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.lastPriceType != rhs.lastPriceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OpenInterest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenInterest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrument_uid"),
    2: .same(proto: "time"),
    3: .standard(proto: "open_interest"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.openInterest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 1)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.openInterest != 0 {
      try visitor.visitSingularInt64Field(value: self.openInterest, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OpenInterest, rhs: OpenInterest) -> Bool {
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs._time != rhs._time {return false}
    if lhs.openInterest != rhs.openInterest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetOrderBookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOrderBookRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._figi) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.depth) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._figi {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if self.depth != 0 {
      try visitor.visitSingularInt32Field(value: self.depth, fieldNumber: 2)
    }
    try { if let v = self._instrumentID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetOrderBookRequest, rhs: GetOrderBookRequest) -> Bool {
    if lhs._figi != rhs._figi {return false}
    if lhs.depth != rhs.depth {return false}
    if lhs._instrumentID != rhs._instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetOrderBookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOrderBookResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "depth"),
    3: .same(proto: "bids"),
    4: .same(proto: "asks"),
    5: .standard(proto: "last_price"),
    6: .standard(proto: "close_price"),
    7: .standard(proto: "limit_up"),
    8: .standard(proto: "limit_down"),
    21: .standard(proto: "last_price_ts"),
    22: .standard(proto: "close_price_ts"),
    23: .standard(proto: "orderbook_ts"),
    9: .standard(proto: "instrument_uid"),
  ]

  fileprivate class _StorageClass {
    var _figi: String = String()
    var _depth: Int32 = 0
    var _bids: [Order] = []
    var _asks: [Order] = []
    var _lastPrice: Quotation? = nil
    var _closePrice: Quotation? = nil
    var _limitUp: Quotation? = nil
    var _limitDown: Quotation? = nil
    var _lastPriceTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _closePriceTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _orderbookTs: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _instrumentUid: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _figi = source._figi
      _depth = source._depth
      _bids = source._bids
      _asks = source._asks
      _lastPrice = source._lastPrice
      _closePrice = source._closePrice
      _limitUp = source._limitUp
      _limitDown = source._limitDown
      _lastPriceTs = source._lastPriceTs
      _closePriceTs = source._closePriceTs
      _orderbookTs = source._orderbookTs
      _instrumentUid = source._instrumentUid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._figi) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._depth) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._bids) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._asks) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._lastPrice) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._closePrice) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._limitUp) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._limitDown) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._instrumentUid) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._lastPriceTs) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._closePriceTs) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._orderbookTs) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._figi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._figi, fieldNumber: 1)
      }
      if _storage._depth != 0 {
        try visitor.visitSingularInt32Field(value: _storage._depth, fieldNumber: 2)
      }
      if !_storage._bids.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bids, fieldNumber: 3)
      }
      if !_storage._asks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._asks, fieldNumber: 4)
      }
      try { if let v = _storage._lastPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._closePrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._limitUp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._limitDown {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._instrumentUid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instrumentUid, fieldNumber: 9)
      }
      try { if let v = _storage._lastPriceTs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._closePriceTs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._orderbookTs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetOrderBookResponse, rhs: GetOrderBookResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._figi != rhs_storage._figi {return false}
        if _storage._depth != rhs_storage._depth {return false}
        if _storage._bids != rhs_storage._bids {return false}
        if _storage._asks != rhs_storage._asks {return false}
        if _storage._lastPrice != rhs_storage._lastPrice {return false}
        if _storage._closePrice != rhs_storage._closePrice {return false}
        if _storage._limitUp != rhs_storage._limitUp {return false}
        if _storage._limitDown != rhs_storage._limitDown {return false}
        if _storage._lastPriceTs != rhs_storage._lastPriceTs {return false}
        if _storage._closePriceTs != rhs_storage._closePriceTs {return false}
        if _storage._orderbookTs != rhs_storage._orderbookTs {return false}
        if _storage._instrumentUid != rhs_storage._instrumentUid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetTradingStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTradingStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._figi {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instrumentID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetTradingStatusRequest, rhs: GetTradingStatusRequest) -> Bool {
    if lhs._figi != rhs._figi {return false}
    if lhs._instrumentID != rhs._instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetTradingStatusesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTradingStatusesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instrumentID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.instrumentID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetTradingStatusesRequest, rhs: GetTradingStatusesRequest) -> Bool {
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetTradingStatusesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTradingStatusesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trading_statuses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tradingStatuses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tradingStatuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tradingStatuses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetTradingStatusesResponse, rhs: GetTradingStatusesResponse) -> Bool {
    if lhs.tradingStatuses != rhs.tradingStatuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetTradingStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTradingStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "trading_status"),
    3: .standard(proto: "limit_order_available_flag"),
    4: .standard(proto: "market_order_available_flag"),
    5: .standard(proto: "api_trade_available_flag"),
    6: .standard(proto: "instrument_uid"),
    8: .standard(proto: "bestprice_order_available_flag"),
    9: .standard(proto: "only_best_price"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.tradingStatus) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.limitOrderAvailableFlag) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.marketOrderAvailableFlag) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.apiTradeAvailableFlag) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.bestpriceOrderAvailableFlag) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.onlyBestPrice) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if self.tradingStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.tradingStatus, fieldNumber: 2)
    }
    if self.limitOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.limitOrderAvailableFlag, fieldNumber: 3)
    }
    if self.marketOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.marketOrderAvailableFlag, fieldNumber: 4)
    }
    if self.apiTradeAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.apiTradeAvailableFlag, fieldNumber: 5)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 6)
    }
    if self.bestpriceOrderAvailableFlag != false {
      try visitor.visitSingularBoolField(value: self.bestpriceOrderAvailableFlag, fieldNumber: 8)
    }
    if self.onlyBestPrice != false {
      try visitor.visitSingularBoolField(value: self.onlyBestPrice, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetTradingStatusResponse, rhs: GetTradingStatusResponse) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.tradingStatus != rhs.tradingStatus {return false}
    if lhs.limitOrderAvailableFlag != rhs.limitOrderAvailableFlag {return false}
    if lhs.marketOrderAvailableFlag != rhs.marketOrderAvailableFlag {return false}
    if lhs.apiTradeAvailableFlag != rhs.apiTradeAvailableFlag {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.bestpriceOrderAvailableFlag != rhs.bestpriceOrderAvailableFlag {return false}
    if lhs.onlyBestPrice != rhs.onlyBestPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetLastTradesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastTradesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .standard(proto: "instrument_id"),
    5: .standard(proto: "trade_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._figi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._instrumentID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.tradeSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._figi {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._instrumentID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if self.tradeSource != .tradeSourceUnspecified {
      try visitor.visitSingularEnumField(value: self.tradeSource, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetLastTradesRequest, rhs: GetLastTradesRequest) -> Bool {
    if lhs._figi != rhs._figi {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs._instrumentID != rhs._instrumentID {return false}
    if lhs.tradeSource != rhs.tradeSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetLastTradesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastTradesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trades"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.trades) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trades.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trades, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetLastTradesResponse, rhs: GetLastTradesResponse) -> Bool {
    if lhs.trades != rhs.trades {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetMySubscriptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMySubscriptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetMySubscriptions, rhs: GetMySubscriptions) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetClosePricesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetClosePricesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruments"),
    9: .standard(proto: "instrument_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self._instrumentStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 1)
    }
    try { if let v = self._instrumentStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetClosePricesRequest, rhs: GetClosePricesRequest) -> Bool {
    if lhs.instruments != rhs.instruments {return false}
    if lhs._instrumentStatus != rhs._instrumentStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InstrumentClosePriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentClosePriceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrument_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instrumentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instrumentID.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InstrumentClosePriceRequest, rhs: InstrumentClosePriceRequest) -> Bool {
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetClosePricesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetClosePricesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "close_prices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.closePrices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.closePrices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.closePrices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetClosePricesResponse, rhs: GetClosePricesResponse) -> Bool {
    if lhs.closePrices != rhs.closePrices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InstrumentClosePriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentClosePriceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "figi"),
    2: .standard(proto: "instrument_uid"),
    11: .same(proto: "price"),
    12: .standard(proto: "evening_session_price"),
    21: .same(proto: "time"),
    23: .standard(proto: "evening_session_price_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.figi) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._eveningSessionPrice) }()
      case 21: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 23: try { try decoder.decodeSingularMessageField(value: &self._eveningSessionPriceTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.figi.isEmpty {
      try visitor.visitSingularStringField(value: self.figi, fieldNumber: 1)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 2)
    }
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._eveningSessionPrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    } }()
    try { if let v = self._eveningSessionPriceTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InstrumentClosePriceResponse, rhs: InstrumentClosePriceResponse) -> Bool {
    if lhs.figi != rhs.figi {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs._price != rhs._price {return false}
    if lhs._eveningSessionPrice != rhs._eveningSessionPrice {return false}
    if lhs._time != rhs._time {return false}
    if lhs._eveningSessionPriceTime != rhs._eveningSessionPriceTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetTechAnalysisRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTechAnalysisRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "indicator_type"),
    2: .standard(proto: "instrument_uid"),
    3: .same(proto: "from"),
    4: .same(proto: "to"),
    5: .same(proto: "interval"),
    6: .standard(proto: "type_of_price"),
    7: .same(proto: "length"),
    8: .same(proto: "deviation"),
    9: .same(proto: "smoothing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.indicatorType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.interval) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.typeOfPrice) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.length) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._deviation) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._smoothing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.indicatorType != .unspecified {
      try visitor.visitSingularEnumField(value: self.indicatorType, fieldNumber: 1)
    }
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 2)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.interval != .unspecified {
      try visitor.visitSingularEnumField(value: self.interval, fieldNumber: 5)
    }
    if self.typeOfPrice != .unspecified {
      try visitor.visitSingularEnumField(value: self.typeOfPrice, fieldNumber: 6)
    }
    if self.length != 0 {
      try visitor.visitSingularInt32Field(value: self.length, fieldNumber: 7)
    }
    try { if let v = self._deviation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._smoothing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetTechAnalysisRequest, rhs: GetTechAnalysisRequest) -> Bool {
    if lhs.indicatorType != rhs.indicatorType {return false}
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.typeOfPrice != rhs.typeOfPrice {return false}
    if lhs.length != rhs.length {return false}
    if lhs._deviation != rhs._deviation {return false}
    if lhs._smoothing != rhs._smoothing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetTechAnalysisRequest.IndicatorInterval: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INDICATOR_INTERVAL_UNSPECIFIED"),
    1: .same(proto: "INDICATOR_INTERVAL_ONE_MINUTE"),
    2: .same(proto: "INDICATOR_INTERVAL_FIVE_MINUTES"),
    3: .same(proto: "INDICATOR_INTERVAL_FIFTEEN_MINUTES"),
    4: .same(proto: "INDICATOR_INTERVAL_ONE_HOUR"),
    5: .same(proto: "INDICATOR_INTERVAL_ONE_DAY"),
    6: .same(proto: "INDICATOR_INTERVAL_2_MIN"),
    7: .same(proto: "INDICATOR_INTERVAL_3_MIN"),
    8: .same(proto: "INDICATOR_INTERVAL_10_MIN"),
    9: .same(proto: "INDICATOR_INTERVAL_30_MIN"),
    10: .same(proto: "INDICATOR_INTERVAL_2_HOUR"),
    11: .same(proto: "INDICATOR_INTERVAL_4_HOUR"),
    12: .same(proto: "INDICATOR_INTERVAL_WEEK"),
    13: .same(proto: "INDICATOR_INTERVAL_MONTH"),
  ]
}

extension GetTechAnalysisRequest.TypeOfPrice: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_OF_PRICE_UNSPECIFIED"),
    1: .same(proto: "TYPE_OF_PRICE_CLOSE"),
    2: .same(proto: "TYPE_OF_PRICE_OPEN"),
    3: .same(proto: "TYPE_OF_PRICE_HIGH"),
    4: .same(proto: "TYPE_OF_PRICE_LOW"),
    5: .same(proto: "TYPE_OF_PRICE_AVG"),
  ]
}

extension GetTechAnalysisRequest.IndicatorType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INDICATOR_TYPE_UNSPECIFIED"),
    1: .same(proto: "INDICATOR_TYPE_BB"),
    2: .same(proto: "INDICATOR_TYPE_EMA"),
    3: .same(proto: "INDICATOR_TYPE_RSI"),
    4: .same(proto: "INDICATOR_TYPE_MACD"),
    5: .same(proto: "INDICATOR_TYPE_SMA"),
  ]
}

extension GetTechAnalysisRequest.Smoothing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = GetTechAnalysisRequest.protoMessageName + ".Smoothing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fast_length"),
    2: .standard(proto: "slow_length"),
    3: .standard(proto: "signal_smoothing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.fastLength) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.slowLength) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.signalSmoothing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fastLength != 0 {
      try visitor.visitSingularInt32Field(value: self.fastLength, fieldNumber: 1)
    }
    if self.slowLength != 0 {
      try visitor.visitSingularInt32Field(value: self.slowLength, fieldNumber: 2)
    }
    if self.signalSmoothing != 0 {
      try visitor.visitSingularInt32Field(value: self.signalSmoothing, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetTechAnalysisRequest.Smoothing, rhs: GetTechAnalysisRequest.Smoothing) -> Bool {
    if lhs.fastLength != rhs.fastLength {return false}
    if lhs.slowLength != rhs.slowLength {return false}
    if lhs.signalSmoothing != rhs.signalSmoothing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetTechAnalysisRequest.Deviation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = GetTechAnalysisRequest.protoMessageName + ".Deviation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deviation_multiplier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deviationMultiplier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deviationMultiplier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetTechAnalysisRequest.Deviation, rhs: GetTechAnalysisRequest.Deviation) -> Bool {
    if lhs._deviationMultiplier != rhs._deviationMultiplier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetTechAnalysisResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTechAnalysisResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "technical_indicators"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.technicalIndicators) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.technicalIndicators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.technicalIndicators, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetTechAnalysisResponse, rhs: GetTechAnalysisResponse) -> Bool {
    if lhs.technicalIndicators != rhs.technicalIndicators {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetTechAnalysisResponse.TechAnalysisItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = GetTechAnalysisResponse.protoMessageName + ".TechAnalysisItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "middle_band"),
    3: .standard(proto: "upper_band"),
    4: .standard(proto: "lower_band"),
    5: .same(proto: "signal"),
    6: .same(proto: "macd"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._middleBand) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._upperBand) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lowerBand) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._signal) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._macd) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._middleBand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._upperBand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._lowerBand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._signal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._macd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetTechAnalysisResponse.TechAnalysisItem, rhs: GetTechAnalysisResponse.TechAnalysisItem) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._middleBand != rhs._middleBand {return false}
    if lhs._upperBand != rhs._upperBand {return false}
    if lhs._lowerBand != rhs._lowerBand {return false}
    if lhs._signal != rhs._signal {return false}
    if lhs._macd != rhs._macd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetMarketValuesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMarketValuesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrument_id"),
    2: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.instrumentID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instrumentID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.instrumentID, fieldNumber: 1)
    }
    if !self.values.isEmpty {
      try visitor.visitPackedEnumField(value: self.values, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetMarketValuesRequest, rhs: GetMarketValuesRequest) -> Bool {
    if lhs.instrumentID != rhs.instrumentID {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetMarketValuesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMarketValuesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instruments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instruments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instruments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetMarketValuesResponse, rhs: GetMarketValuesResponse) -> Bool {
    if lhs.instruments != rhs.instruments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MarketValueInstrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketValueInstrument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrument_uid"),
    2: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instrumentUid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instrumentUid.isEmpty {
      try visitor.visitSingularStringField(value: self.instrumentUid, fieldNumber: 1)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MarketValueInstrument, rhs: MarketValueInstrument) -> Bool {
    if lhs.instrumentUid != rhs.instrumentUid {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MarketValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
    3: .same(proto: "time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MarketValue, rhs: MarketValue) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._value != rhs._value {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
